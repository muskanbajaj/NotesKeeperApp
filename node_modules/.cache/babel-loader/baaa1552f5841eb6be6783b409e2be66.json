{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isResumableError = exports.isNetworkTimeoutError = exports.isSDAMUnrecoverableError = exports.isNodeShuttingDownError = exports.isRetryableReadError = exports.isRetryableWriteError = exports.needsRetryableWriteLabel = exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.isNetworkErrorBeforeHandshake = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;\n/** @internal */\n\nvar kErrorLabels = Symbol('errorLabels');\n/**\n * @internal\n * The legacy error message from the server that indicates the node is not a writable primary\n * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering\n */\n\nexports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp('not master', 'i');\n/**\n * @internal\n * The legacy error message from the server that indicates the node is not a primary or secondary\n * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering\n */\n\nexports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp('not master or secondary', 'i');\n/**\n * @internal\n * The error message from the server that indicates the node is recovering\n * https://github.com/mongodb/specifications/blob/b07c26dc40d04ac20349f989db531c9845fdd755/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-writable-primary-and-node-is-recovering\n */\n\nexports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp('node is recovering', 'i');\n/** @internal MongoDB Error Codes */\n\nexports.MONGODB_ERROR_CODES = Object.freeze({\n  HostUnreachable: 6,\n  HostNotFound: 7,\n  NetworkTimeout: 89,\n  ShutdownInProgress: 91,\n  PrimarySteppedDown: 189,\n  ExceededTimeLimit: 262,\n  SocketException: 9001,\n  NotWritablePrimary: 10107,\n  InterruptedAtShutdown: 11600,\n  InterruptedDueToReplStateChange: 11602,\n  NotPrimaryNoSecondaryOk: 13435,\n  NotPrimaryOrSecondary: 13436,\n  StaleShardVersion: 63,\n  StaleEpoch: 150,\n  StaleConfig: 13388,\n  RetryChangeStream: 234,\n  FailedToSatisfyReadPreference: 133,\n  CursorNotFound: 43,\n  LegacyNotPrimary: 10058,\n  WriteConcernFailed: 64,\n  NamespaceNotFound: 26,\n  IllegalOperation: 20,\n  MaxTimeMSExpired: 50,\n  UnknownReplWriteConcern: 79,\n  UnsatisfiableWriteConcern: 100\n}); // From spec@https://github.com/mongodb/specifications/blob/f93d78191f3db2898a59013a7ed5650352ef6da8/source/change-streams/change-streams.rst#resumable-error\n\nexports.GET_MORE_RESUMABLE_CODES = new Set([exports.MONGODB_ERROR_CODES.HostUnreachable, exports.MONGODB_ERROR_CODES.HostNotFound, exports.MONGODB_ERROR_CODES.NetworkTimeout, exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.ExceededTimeLimit, exports.MONGODB_ERROR_CODES.SocketException, exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary, exports.MONGODB_ERROR_CODES.StaleShardVersion, exports.MONGODB_ERROR_CODES.StaleEpoch, exports.MONGODB_ERROR_CODES.StaleConfig, exports.MONGODB_ERROR_CODES.RetryChangeStream, exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference, exports.MONGODB_ERROR_CODES.CursorNotFound]);\n/** @public */\n\nexports.MongoErrorLabel = Object.freeze({\n  RetryableWriteError: 'RetryableWriteError',\n  TransientTransactionError: 'TransientTransactionError',\n  UnknownTransactionCommitResult: 'UnknownTransactionCommitResult',\n  ResumableChangeStreamError: 'ResumableChangeStreamError',\n  HandshakeError: 'HandshakeError'\n});\n/**\n * @public\n * @category Error\n *\n * @privateRemarks\n * CSFLE has a dependency on this error, it uses the constructor with a string argument\n */\n\nvar MongoError = /*#__PURE__*/function (_Error) {\n  _inherits(MongoError, _Error);\n\n  var _super = _createSuper(MongoError);\n\n  function MongoError(message) {\n    var _this;\n\n    _classCallCheck(this, MongoError);\n\n    if (message instanceof Error) {\n      _this = _super.call(this, message.message);\n    } else {\n      _this = _super.call(this, message);\n    }\n\n    _this[kErrorLabels] = new Set();\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(MongoError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoError';\n    }\n    /** Legacy name for server error responses */\n\n  }, {\n    key: \"errmsg\",\n    get: function get() {\n      return this.message;\n    }\n    /**\n     * Checks the error to see if it has an error label\n     *\n     * @param label - The error label to check for\n     * @returns returns true if the error has the provided error label\n     */\n\n  }, {\n    key: \"hasErrorLabel\",\n    value: function hasErrorLabel(label) {\n      return this[kErrorLabels].has(label);\n    }\n  }, {\n    key: \"addErrorLabel\",\n    value: function addErrorLabel(label) {\n      this[kErrorLabels].add(label);\n    }\n  }, {\n    key: \"errorLabels\",\n    get: function get() {\n      return Array.from(this[kErrorLabels]);\n    }\n  }]);\n\n  return MongoError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.MongoError = MongoError;\n/**\n * An error coming from the mongo server\n *\n * @public\n * @category Error\n */\n\nvar MongoServerError = /*#__PURE__*/function (_MongoError) {\n  _inherits(MongoServerError, _MongoError);\n\n  var _super2 = _createSuper(MongoServerError);\n\n  function MongoServerError(message) {\n    var _this2;\n\n    _classCallCheck(this, MongoServerError);\n\n    _this2 = _super2.call(this, message.message || message.errmsg || message.$err || 'n/a');\n\n    if (message.errorLabels) {\n      _this2[kErrorLabels] = new Set(message.errorLabels);\n    }\n\n    for (var name in message) {\n      if (name !== 'errorLabels' && name !== 'errmsg' && name !== 'message') _this2[name] = message[name];\n    }\n\n    return _this2;\n  }\n\n  _createClass(MongoServerError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoServerError';\n    }\n  }]);\n\n  return MongoServerError;\n}(MongoError);\n\nexports.MongoServerError = MongoServerError;\n/**\n * An error generated by the driver\n *\n * @public\n * @category Error\n */\n\nvar MongoDriverError = /*#__PURE__*/function (_MongoError2) {\n  _inherits(MongoDriverError, _MongoError2);\n\n  var _super3 = _createSuper(MongoDriverError);\n\n  function MongoDriverError(message) {\n    _classCallCheck(this, MongoDriverError);\n\n    return _super3.call(this, message);\n  }\n\n  _createClass(MongoDriverError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoDriverError';\n    }\n  }]);\n\n  return MongoDriverError;\n}(MongoError);\n\nexports.MongoDriverError = MongoDriverError;\n/**\n * An error generated when the driver API is used incorrectly\n *\n * @privateRemarks\n * Should **never** be directly instantiated\n *\n * @public\n * @category Error\n */\n\nvar MongoAPIError = /*#__PURE__*/function (_MongoDriverError) {\n  _inherits(MongoAPIError, _MongoDriverError);\n\n  var _super4 = _createSuper(MongoAPIError);\n\n  function MongoAPIError(message) {\n    _classCallCheck(this, MongoAPIError);\n\n    return _super4.call(this, message);\n  }\n\n  _createClass(MongoAPIError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoAPIError';\n    }\n  }]);\n\n  return MongoAPIError;\n}(MongoDriverError);\n\nexports.MongoAPIError = MongoAPIError;\n/**\n * An error generated when the driver encounters unexpected input\n * or reaches an unexpected/invalid internal state\n *\n * @privateRemarks\n * Should **never** be directly instantiated.\n *\n * @public\n * @category Error\n */\n\nvar MongoRuntimeError = /*#__PURE__*/function (_MongoDriverError2) {\n  _inherits(MongoRuntimeError, _MongoDriverError2);\n\n  var _super5 = _createSuper(MongoRuntimeError);\n\n  function MongoRuntimeError(message) {\n    _classCallCheck(this, MongoRuntimeError);\n\n    return _super5.call(this, message);\n  }\n\n  _createClass(MongoRuntimeError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoRuntimeError';\n    }\n  }]);\n\n  return MongoRuntimeError;\n}(MongoDriverError);\n\nexports.MongoRuntimeError = MongoRuntimeError;\n/**\n * An error generated when a batch command is re-executed after one of the commands in the batch\n * has failed\n *\n * @public\n * @category Error\n */\n\nvar MongoBatchReExecutionError = /*#__PURE__*/function (_MongoAPIError) {\n  _inherits(MongoBatchReExecutionError, _MongoAPIError);\n\n  var _super6 = _createSuper(MongoBatchReExecutionError);\n\n  function MongoBatchReExecutionError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'This batch has already been executed, create new batch to execute';\n\n    _classCallCheck(this, MongoBatchReExecutionError);\n\n    return _super6.call(this, message);\n  }\n\n  _createClass(MongoBatchReExecutionError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoBatchReExecutionError';\n    }\n  }]);\n\n  return MongoBatchReExecutionError;\n}(MongoAPIError);\n\nexports.MongoBatchReExecutionError = MongoBatchReExecutionError;\n/**\n * An error generated when the driver fails to decompress\n * data received from the server.\n *\n * @public\n * @category Error\n */\n\nvar MongoDecompressionError = /*#__PURE__*/function (_MongoRuntimeError) {\n  _inherits(MongoDecompressionError, _MongoRuntimeError);\n\n  var _super7 = _createSuper(MongoDecompressionError);\n\n  function MongoDecompressionError(message) {\n    _classCallCheck(this, MongoDecompressionError);\n\n    return _super7.call(this, message);\n  }\n\n  _createClass(MongoDecompressionError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoDecompressionError';\n    }\n  }]);\n\n  return MongoDecompressionError;\n}(MongoRuntimeError);\n\nexports.MongoDecompressionError = MongoDecompressionError;\n/**\n * An error thrown when the user attempts to operate on a database or collection through a MongoClient\n * that has not yet successfully called the \"connect\" method\n *\n * @public\n * @category Error\n */\n\nvar MongoNotConnectedError = /*#__PURE__*/function (_MongoAPIError2) {\n  _inherits(MongoNotConnectedError, _MongoAPIError2);\n\n  var _super8 = _createSuper(MongoNotConnectedError);\n\n  function MongoNotConnectedError(message) {\n    _classCallCheck(this, MongoNotConnectedError);\n\n    return _super8.call(this, message);\n  }\n\n  _createClass(MongoNotConnectedError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoNotConnectedError';\n    }\n  }]);\n\n  return MongoNotConnectedError;\n}(MongoAPIError);\n\nexports.MongoNotConnectedError = MongoNotConnectedError;\n/**\n * An error generated when the user makes a mistake in the usage of transactions.\n * (e.g. attempting to commit a transaction with a readPreference other than primary)\n *\n * @public\n * @category Error\n */\n\nvar MongoTransactionError = /*#__PURE__*/function (_MongoAPIError3) {\n  _inherits(MongoTransactionError, _MongoAPIError3);\n\n  var _super9 = _createSuper(MongoTransactionError);\n\n  function MongoTransactionError(message) {\n    _classCallCheck(this, MongoTransactionError);\n\n    return _super9.call(this, message);\n  }\n\n  _createClass(MongoTransactionError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoTransactionError';\n    }\n  }]);\n\n  return MongoTransactionError;\n}(MongoAPIError);\n\nexports.MongoTransactionError = MongoTransactionError;\n/**\n * An error generated when the user attempts to operate\n * on a session that has expired or has been closed.\n *\n * @public\n * @category Error\n */\n\nvar MongoExpiredSessionError = /*#__PURE__*/function (_MongoAPIError4) {\n  _inherits(MongoExpiredSessionError, _MongoAPIError4);\n\n  var _super10 = _createSuper(MongoExpiredSessionError);\n\n  function MongoExpiredSessionError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cannot use a session that has ended';\n\n    _classCallCheck(this, MongoExpiredSessionError);\n\n    return _super10.call(this, message);\n  }\n\n  _createClass(MongoExpiredSessionError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoExpiredSessionError';\n    }\n  }]);\n\n  return MongoExpiredSessionError;\n}(MongoAPIError);\n\nexports.MongoExpiredSessionError = MongoExpiredSessionError;\n/**\n * A error generated when the user attempts to authenticate\n * via Kerberos, but fails to connect to the Kerberos client.\n *\n * @public\n * @category Error\n */\n\nvar MongoKerberosError = /*#__PURE__*/function (_MongoRuntimeError2) {\n  _inherits(MongoKerberosError, _MongoRuntimeError2);\n\n  var _super11 = _createSuper(MongoKerberosError);\n\n  function MongoKerberosError(message) {\n    _classCallCheck(this, MongoKerberosError);\n\n    return _super11.call(this, message);\n  }\n\n  _createClass(MongoKerberosError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoKerberosError';\n    }\n  }]);\n\n  return MongoKerberosError;\n}(MongoRuntimeError);\n\nexports.MongoKerberosError = MongoKerberosError;\n/**\n * A error generated when the user attempts to authenticate\n * via AWS, but fails\n *\n * @public\n * @category Error\n */\n\nvar MongoAWSError = /*#__PURE__*/function (_MongoRuntimeError3) {\n  _inherits(MongoAWSError, _MongoRuntimeError3);\n\n  var _super12 = _createSuper(MongoAWSError);\n\n  function MongoAWSError(message) {\n    _classCallCheck(this, MongoAWSError);\n\n    return _super12.call(this, message);\n  }\n\n  _createClass(MongoAWSError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoAWSError';\n    }\n  }]);\n\n  return MongoAWSError;\n}(MongoRuntimeError);\n\nexports.MongoAWSError = MongoAWSError;\n/**\n * An error generated when a ChangeStream operation fails to execute.\n *\n * @public\n * @category Error\n */\n\nvar MongoChangeStreamError = /*#__PURE__*/function (_MongoRuntimeError4) {\n  _inherits(MongoChangeStreamError, _MongoRuntimeError4);\n\n  var _super13 = _createSuper(MongoChangeStreamError);\n\n  function MongoChangeStreamError(message) {\n    _classCallCheck(this, MongoChangeStreamError);\n\n    return _super13.call(this, message);\n  }\n\n  _createClass(MongoChangeStreamError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoChangeStreamError';\n    }\n  }]);\n\n  return MongoChangeStreamError;\n}(MongoRuntimeError);\n\nexports.MongoChangeStreamError = MongoChangeStreamError;\n/**\n * An error thrown when the user calls a function or method not supported on a tailable cursor\n *\n * @public\n * @category Error\n */\n\nvar MongoTailableCursorError = /*#__PURE__*/function (_MongoAPIError5) {\n  _inherits(MongoTailableCursorError, _MongoAPIError5);\n\n  var _super14 = _createSuper(MongoTailableCursorError);\n\n  function MongoTailableCursorError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Tailable cursor does not support this operation';\n\n    _classCallCheck(this, MongoTailableCursorError);\n\n    return _super14.call(this, message);\n  }\n\n  _createClass(MongoTailableCursorError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoTailableCursorError';\n    }\n  }]);\n\n  return MongoTailableCursorError;\n}(MongoAPIError);\n\nexports.MongoTailableCursorError = MongoTailableCursorError;\n/** An error generated when a GridFSStream operation fails to execute.\n *\n * @public\n * @category Error\n */\n\nvar MongoGridFSStreamError = /*#__PURE__*/function (_MongoRuntimeError5) {\n  _inherits(MongoGridFSStreamError, _MongoRuntimeError5);\n\n  var _super15 = _createSuper(MongoGridFSStreamError);\n\n  function MongoGridFSStreamError(message) {\n    _classCallCheck(this, MongoGridFSStreamError);\n\n    return _super15.call(this, message);\n  }\n\n  _createClass(MongoGridFSStreamError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoGridFSStreamError';\n    }\n  }]);\n\n  return MongoGridFSStreamError;\n}(MongoRuntimeError);\n\nexports.MongoGridFSStreamError = MongoGridFSStreamError;\n/**\n * An error generated when a malformed or invalid chunk is\n * encountered when reading from a GridFSStream.\n *\n * @public\n * @category Error\n */\n\nvar MongoGridFSChunkError = /*#__PURE__*/function (_MongoRuntimeError6) {\n  _inherits(MongoGridFSChunkError, _MongoRuntimeError6);\n\n  var _super16 = _createSuper(MongoGridFSChunkError);\n\n  function MongoGridFSChunkError(message) {\n    _classCallCheck(this, MongoGridFSChunkError);\n\n    return _super16.call(this, message);\n  }\n\n  _createClass(MongoGridFSChunkError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoGridFSChunkError';\n    }\n  }]);\n\n  return MongoGridFSChunkError;\n}(MongoRuntimeError);\n\nexports.MongoGridFSChunkError = MongoGridFSChunkError;\n/**\n * An error generated when a **parsable** unexpected response comes from the server.\n * This is generally an error where the driver in a state expecting a certain behavior to occur in\n * the next message from MongoDB but it receives something else.\n * This error **does not** represent an issue with wire message formatting.\n *\n * #### Example\n * When an operation fails, it is the driver's job to retry it. It must perform serverSelection\n * again to make sure that it attempts the operation against a server in a good state. If server\n * selection returns a server that does not support retryable operations, this error is used.\n * This scenario is unlikely as retryable support would also have been determined on the first attempt\n * but it is possible the state change could report a selectable server that does not support retries.\n *\n * @public\n * @category Error\n */\n\nvar MongoUnexpectedServerResponseError = /*#__PURE__*/function (_MongoRuntimeError7) {\n  _inherits(MongoUnexpectedServerResponseError, _MongoRuntimeError7);\n\n  var _super17 = _createSuper(MongoUnexpectedServerResponseError);\n\n  function MongoUnexpectedServerResponseError(message) {\n    _classCallCheck(this, MongoUnexpectedServerResponseError);\n\n    return _super17.call(this, message);\n  }\n\n  _createClass(MongoUnexpectedServerResponseError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoUnexpectedServerResponseError';\n    }\n  }]);\n\n  return MongoUnexpectedServerResponseError;\n}(MongoRuntimeError);\n\nexports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;\n/**\n * An error thrown when the user attempts to add options to a cursor that has already been\n * initialized\n *\n * @public\n * @category Error\n */\n\nvar MongoCursorInUseError = /*#__PURE__*/function (_MongoAPIError6) {\n  _inherits(MongoCursorInUseError, _MongoAPIError6);\n\n  var _super18 = _createSuper(MongoCursorInUseError);\n\n  function MongoCursorInUseError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cursor is already initialized';\n\n    _classCallCheck(this, MongoCursorInUseError);\n\n    return _super18.call(this, message);\n  }\n\n  _createClass(MongoCursorInUseError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoCursorInUseError';\n    }\n  }]);\n\n  return MongoCursorInUseError;\n}(MongoAPIError);\n\nexports.MongoCursorInUseError = MongoCursorInUseError;\n/**\n * An error generated when an attempt is made to operate\n * on a closed/closing server.\n *\n * @public\n * @category Error\n */\n\nvar MongoServerClosedError = /*#__PURE__*/function (_MongoAPIError7) {\n  _inherits(MongoServerClosedError, _MongoAPIError7);\n\n  var _super19 = _createSuper(MongoServerClosedError);\n\n  function MongoServerClosedError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Server is closed';\n\n    _classCallCheck(this, MongoServerClosedError);\n\n    return _super19.call(this, message);\n  }\n\n  _createClass(MongoServerClosedError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoServerClosedError';\n    }\n  }]);\n\n  return MongoServerClosedError;\n}(MongoAPIError);\n\nexports.MongoServerClosedError = MongoServerClosedError;\n/**\n * An error thrown when an attempt is made to read from a cursor that has been exhausted\n *\n * @public\n * @category Error\n */\n\nvar MongoCursorExhaustedError = /*#__PURE__*/function (_MongoAPIError8) {\n  _inherits(MongoCursorExhaustedError, _MongoAPIError8);\n\n  var _super20 = _createSuper(MongoCursorExhaustedError);\n\n  function MongoCursorExhaustedError(message) {\n    _classCallCheck(this, MongoCursorExhaustedError);\n\n    return _super20.call(this, message || 'Cursor is exhausted');\n  }\n\n  _createClass(MongoCursorExhaustedError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoCursorExhaustedError';\n    }\n  }]);\n\n  return MongoCursorExhaustedError;\n}(MongoAPIError);\n\nexports.MongoCursorExhaustedError = MongoCursorExhaustedError;\n/**\n * An error generated when an attempt is made to operate on a\n * dropped, or otherwise unavailable, database.\n *\n * @public\n * @category Error\n */\n\nvar MongoTopologyClosedError = /*#__PURE__*/function (_MongoAPIError9) {\n  _inherits(MongoTopologyClosedError, _MongoAPIError9);\n\n  var _super21 = _createSuper(MongoTopologyClosedError);\n\n  function MongoTopologyClosedError() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Topology is closed';\n\n    _classCallCheck(this, MongoTopologyClosedError);\n\n    return _super21.call(this, message);\n  }\n\n  _createClass(MongoTopologyClosedError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoTopologyClosedError';\n    }\n  }]);\n\n  return MongoTopologyClosedError;\n}(MongoAPIError);\n\nexports.MongoTopologyClosedError = MongoTopologyClosedError;\n/** @internal */\n\nvar kBeforeHandshake = Symbol('beforeHandshake');\n\nfunction isNetworkErrorBeforeHandshake(err) {\n  return err[kBeforeHandshake] === true;\n}\n\nexports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;\n/**\n * An error indicating an issue with the network, including TCP errors and timeouts.\n * @public\n * @category Error\n */\n\nvar MongoNetworkError = /*#__PURE__*/function (_MongoError3) {\n  _inherits(MongoNetworkError, _MongoError3);\n\n  var _super22 = _createSuper(MongoNetworkError);\n\n  function MongoNetworkError(message, options) {\n    var _this3;\n\n    _classCallCheck(this, MongoNetworkError);\n\n    _this3 = _super22.call(this, message);\n\n    if (options && typeof options.beforeHandshake === 'boolean') {\n      _this3[kBeforeHandshake] = options.beforeHandshake;\n    }\n\n    return _this3;\n  }\n\n  _createClass(MongoNetworkError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoNetworkError';\n    }\n  }]);\n\n  return MongoNetworkError;\n}(MongoError);\n\nexports.MongoNetworkError = MongoNetworkError;\n/**\n * An error indicating a network timeout occurred\n * @public\n * @category Error\n *\n * @privateRemarks\n * CSFLE has a dependency on this error with an instanceof check\n */\n\nvar MongoNetworkTimeoutError = /*#__PURE__*/function (_MongoNetworkError) {\n  _inherits(MongoNetworkTimeoutError, _MongoNetworkError);\n\n  var _super23 = _createSuper(MongoNetworkTimeoutError);\n\n  function MongoNetworkTimeoutError(message, options) {\n    _classCallCheck(this, MongoNetworkTimeoutError);\n\n    return _super23.call(this, message, options);\n  }\n\n  _createClass(MongoNetworkTimeoutError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoNetworkTimeoutError';\n    }\n  }]);\n\n  return MongoNetworkTimeoutError;\n}(MongoNetworkError);\n\nexports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;\n/**\n * An error used when attempting to parse a value (like a connection string)\n * @public\n * @category Error\n */\n\nvar MongoParseError = /*#__PURE__*/function (_MongoDriverError3) {\n  _inherits(MongoParseError, _MongoDriverError3);\n\n  var _super24 = _createSuper(MongoParseError);\n\n  function MongoParseError(message) {\n    _classCallCheck(this, MongoParseError);\n\n    return _super24.call(this, message);\n  }\n\n  _createClass(MongoParseError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoParseError';\n    }\n  }]);\n\n  return MongoParseError;\n}(MongoDriverError);\n\nexports.MongoParseError = MongoParseError;\n/**\n * An error generated when the user supplies malformed or unexpected arguments\n * or when a required argument or field is not provided.\n *\n *\n * @public\n * @category Error\n */\n\nvar MongoInvalidArgumentError = /*#__PURE__*/function (_MongoAPIError10) {\n  _inherits(MongoInvalidArgumentError, _MongoAPIError10);\n\n  var _super25 = _createSuper(MongoInvalidArgumentError);\n\n  function MongoInvalidArgumentError(message) {\n    _classCallCheck(this, MongoInvalidArgumentError);\n\n    return _super25.call(this, message);\n  }\n\n  _createClass(MongoInvalidArgumentError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoInvalidArgumentError';\n    }\n  }]);\n\n  return MongoInvalidArgumentError;\n}(MongoAPIError);\n\nexports.MongoInvalidArgumentError = MongoInvalidArgumentError;\n/**\n * An error generated when a feature that is not enabled or allowed for the current server\n * configuration is used\n *\n *\n * @public\n * @category Error\n */\n\nvar MongoCompatibilityError = /*#__PURE__*/function (_MongoAPIError11) {\n  _inherits(MongoCompatibilityError, _MongoAPIError11);\n\n  var _super26 = _createSuper(MongoCompatibilityError);\n\n  function MongoCompatibilityError(message) {\n    _classCallCheck(this, MongoCompatibilityError);\n\n    return _super26.call(this, message);\n  }\n\n  _createClass(MongoCompatibilityError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoCompatibilityError';\n    }\n  }]);\n\n  return MongoCompatibilityError;\n}(MongoAPIError);\n\nexports.MongoCompatibilityError = MongoCompatibilityError;\n/**\n * An error generated when the user fails to provide authentication credentials before attempting\n * to connect to a mongo server instance.\n *\n *\n * @public\n * @category Error\n */\n\nvar MongoMissingCredentialsError = /*#__PURE__*/function (_MongoAPIError12) {\n  _inherits(MongoMissingCredentialsError, _MongoAPIError12);\n\n  var _super27 = _createSuper(MongoMissingCredentialsError);\n\n  function MongoMissingCredentialsError(message) {\n    _classCallCheck(this, MongoMissingCredentialsError);\n\n    return _super27.call(this, message);\n  }\n\n  _createClass(MongoMissingCredentialsError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoMissingCredentialsError';\n    }\n  }]);\n\n  return MongoMissingCredentialsError;\n}(MongoAPIError);\n\nexports.MongoMissingCredentialsError = MongoMissingCredentialsError;\n/**\n * An error generated when a required module or dependency is not present in the local environment\n *\n * @public\n * @category Error\n */\n\nvar MongoMissingDependencyError = /*#__PURE__*/function (_MongoAPIError13) {\n  _inherits(MongoMissingDependencyError, _MongoAPIError13);\n\n  var _super28 = _createSuper(MongoMissingDependencyError);\n\n  function MongoMissingDependencyError(message) {\n    _classCallCheck(this, MongoMissingDependencyError);\n\n    return _super28.call(this, message);\n  }\n\n  _createClass(MongoMissingDependencyError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoMissingDependencyError';\n    }\n  }]);\n\n  return MongoMissingDependencyError;\n}(MongoAPIError);\n\nexports.MongoMissingDependencyError = MongoMissingDependencyError;\n/**\n * An error signifying a general system issue\n * @public\n * @category Error\n */\n\nvar MongoSystemError = /*#__PURE__*/function (_MongoError4) {\n  _inherits(MongoSystemError, _MongoError4);\n\n  var _super29 = _createSuper(MongoSystemError);\n\n  function MongoSystemError(message, reason) {\n    var _this4;\n\n    _classCallCheck(this, MongoSystemError);\n\n    var _a;\n\n    if (reason && reason.error) {\n      _this4 = _super29.call(this, reason.error.message || reason.error);\n    } else {\n      _this4 = _super29.call(this, message);\n    }\n\n    if (reason) {\n      _this4.reason = reason;\n    }\n\n    _this4.code = (_a = reason.error) === null || _a === void 0 ? void 0 : _a.code;\n    return _possibleConstructorReturn(_this4);\n  }\n\n  _createClass(MongoSystemError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoSystemError';\n    }\n  }]);\n\n  return MongoSystemError;\n}(MongoError);\n\nexports.MongoSystemError = MongoSystemError;\n/**\n * An error signifying a client-side server selection error\n * @public\n * @category Error\n */\n\nvar MongoServerSelectionError = /*#__PURE__*/function (_MongoSystemError) {\n  _inherits(MongoServerSelectionError, _MongoSystemError);\n\n  var _super30 = _createSuper(MongoServerSelectionError);\n\n  function MongoServerSelectionError(message, reason) {\n    _classCallCheck(this, MongoServerSelectionError);\n\n    return _super30.call(this, message, reason);\n  }\n\n  _createClass(MongoServerSelectionError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoServerSelectionError';\n    }\n  }]);\n\n  return MongoServerSelectionError;\n}(MongoSystemError);\n\nexports.MongoServerSelectionError = MongoServerSelectionError;\n\nfunction makeWriteConcernResultObject(input) {\n  var output = Object.assign({}, input);\n\n  if (output.ok === 0) {\n    output.ok = 1;\n    delete output.errmsg;\n    delete output.code;\n    delete output.codeName;\n  }\n\n  return output;\n}\n/**\n * An error thrown when the server reports a writeConcernError\n * @public\n * @category Error\n */\n\n\nvar MongoWriteConcernError = /*#__PURE__*/function (_MongoServerError) {\n  _inherits(MongoWriteConcernError, _MongoServerError);\n\n  var _super31 = _createSuper(MongoWriteConcernError);\n\n  function MongoWriteConcernError(message, result) {\n    var _this5;\n\n    _classCallCheck(this, MongoWriteConcernError);\n\n    if (result && Array.isArray(result.errorLabels)) {\n      message.errorLabels = result.errorLabels;\n    }\n\n    _this5 = _super31.call(this, message);\n    _this5.errInfo = message.errInfo;\n\n    if (result != null) {\n      _this5.result = makeWriteConcernResultObject(result);\n    }\n\n    return _this5;\n  }\n\n  _createClass(MongoWriteConcernError, [{\n    key: \"name\",\n    get: function get() {\n      return 'MongoWriteConcernError';\n    }\n  }]);\n\n  return MongoWriteConcernError;\n}(MongoServerError);\n\nexports.MongoWriteConcernError = MongoWriteConcernError; // https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.rst#retryable-error\n\nvar RETRYABLE_READ_ERROR_CODES = new Set([exports.MONGODB_ERROR_CODES.HostUnreachable, exports.MONGODB_ERROR_CODES.HostNotFound, exports.MONGODB_ERROR_CODES.NetworkTimeout, exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.SocketException, exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary]); // see: https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst#terms\n\nvar RETRYABLE_WRITE_ERROR_CODES = new Set([].concat(_toConsumableArray(RETRYABLE_READ_ERROR_CODES), [exports.MONGODB_ERROR_CODES.ExceededTimeLimit]));\n\nfunction needsRetryableWriteLabel(error, maxWireVersion) {\n  var _a, _b, _c; // pre-4.4 server, then the driver adds an error label for every valid case\n  // execute operation will only inspect the label, code/message logic is handled here\n\n\n  if (error instanceof MongoNetworkError) {\n    return true;\n  }\n\n  if (error instanceof MongoError) {\n    if ((maxWireVersion >= 9 || error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError)) && !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {\n      // If we already have the error label no need to add it again. 4.4+ servers add the label.\n      // In the case where we have a handshake error, need to fall down to the logic checking\n      // the codes.\n      return false;\n    }\n  }\n\n  if (error instanceof MongoWriteConcernError) {\n    return RETRYABLE_WRITE_ERROR_CODES.has((_c = (_b = (_a = error.result) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : error.code) !== null && _c !== void 0 ? _c : 0);\n  }\n\n  if (error instanceof MongoError && typeof error.code === 'number') {\n    return RETRYABLE_WRITE_ERROR_CODES.has(error.code);\n  }\n\n  var isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);\n\n  if (isNotWritablePrimaryError) {\n    return true;\n  }\n\n  var isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);\n\n  if (isNodeIsRecoveringError) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.needsRetryableWriteLabel = needsRetryableWriteLabel;\n\nfunction isRetryableWriteError(error) {\n  return error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError);\n}\n\nexports.isRetryableWriteError = isRetryableWriteError;\n/** Determines whether an error is something the driver should attempt to retry */\n\nfunction isRetryableReadError(error) {\n  var hasRetryableErrorCode = typeof error.code === 'number' ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;\n\n  if (hasRetryableErrorCode) {\n    return true;\n  }\n\n  if (error instanceof MongoNetworkError) {\n    return true;\n  }\n\n  var isNotWritablePrimaryError = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);\n\n  if (isNotWritablePrimaryError) {\n    return true;\n  }\n\n  var isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);\n\n  if (isNodeIsRecoveringError) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isRetryableReadError = isRetryableReadError;\nvar SDAM_RECOVERING_CODES = new Set([exports.MONGODB_ERROR_CODES.ShutdownInProgress, exports.MONGODB_ERROR_CODES.PrimarySteppedDown, exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange, exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary]);\nvar SDAM_NOT_PRIMARY_CODES = new Set([exports.MONGODB_ERROR_CODES.NotWritablePrimary, exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk, exports.MONGODB_ERROR_CODES.LegacyNotPrimary]);\nvar SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([exports.MONGODB_ERROR_CODES.InterruptedAtShutdown, exports.MONGODB_ERROR_CODES.ShutdownInProgress]);\n\nfunction isRecoveringError(err) {\n  if (typeof err.code === 'number') {\n    // If any error code exists, we ignore the error.message\n    return SDAM_RECOVERING_CODES.has(err.code);\n  }\n\n  return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);\n}\n\nfunction isNotWritablePrimaryError(err) {\n  if (typeof err.code === 'number') {\n    // If any error code exists, we ignore the error.message\n    return SDAM_NOT_PRIMARY_CODES.has(err.code);\n  }\n\n  if (isRecoveringError(err)) {\n    return false;\n  }\n\n  return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);\n}\n\nfunction isNodeShuttingDownError(err) {\n  return !!(typeof err.code === 'number' && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));\n}\n\nexports.isNodeShuttingDownError = isNodeShuttingDownError;\n/**\n * Determines whether SDAM can recover from a given error. If it cannot\n * then the pool will be cleared, and server state will completely reset\n * locally.\n *\n * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering\n */\n\nfunction isSDAMUnrecoverableError(error) {\n  // NOTE: null check is here for a strictly pre-CMAP world, a timeout or\n  //       close event are considered unrecoverable\n  if (error instanceof MongoParseError || error == null) {\n    return true;\n  }\n\n  return isRecoveringError(error) || isNotWritablePrimaryError(error);\n}\n\nexports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;\n\nfunction isNetworkTimeoutError(err) {\n  return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));\n}\n\nexports.isNetworkTimeoutError = isNetworkTimeoutError;\n\nfunction isResumableError(error, wireVersion) {\n  if (error == null || !(error instanceof MongoError)) {\n    return false;\n  }\n\n  if (error instanceof MongoNetworkError) {\n    return true;\n  }\n\n  if (wireVersion != null && wireVersion >= 9) {\n    // DRIVERS-1308: For 4.4 drivers running against 4.4 servers, drivers will add a special case to treat the CursorNotFound error code as resumable\n    if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {\n      return true;\n    }\n\n    return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);\n  }\n\n  if (typeof error.code === 'number') {\n    return exports.GET_MORE_RESUMABLE_CODES.has(error.code);\n  }\n\n  return false;\n}\n\nexports.isResumableError = isResumableError;","map":null,"metadata":{},"sourceType":"script"}