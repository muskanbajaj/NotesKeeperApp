{"ast":null,"code":"\"use strict\";\n\nvar _toArray = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/toArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(makeCounter);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;\nexports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = void 0;\n\nvar crypto = require(\"crypto\");\n\nvar os = require(\"os\");\n\nvar timers_1 = require(\"timers\");\n\nvar url_1 = require(\"url\");\n\nvar bson_1 = require(\"./bson\");\n\nvar constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nvar constants_2 = require(\"./constants\");\n\nvar error_1 = require(\"./error\");\n\nvar promise_provider_1 = require(\"./promise_provider\");\n\nvar read_concern_1 = require(\"./read_concern\");\n\nvar read_preference_1 = require(\"./read_preference\");\n\nvar common_1 = require(\"./sdam/common\");\n\nvar write_concern_1 = require(\"./write_concern\");\n\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  var finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\n\nfunction parseIndexOptions(indexSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          value = _ref2[1];\n\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\n\nexports.parseIndexOptions = parseIndexOptions;\n\nvar TO_STRING = function TO_STRING(object) {\n  return Object.prototype.toString.call(object);\n};\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n\n\nfunction isObject(arg) {\n  return '[object Object]' === TO_STRING(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return _objectSpread(_objectSpread({}, target), source);\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  var _a;\n\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  var db = sources.db;\n  var coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  var writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern: writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  var capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(\"Current topology does not support collation\");\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  var readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\n\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\n\nfunction defaultMsgHandler(name, option) {\n  return \"\".concat(name, \" option [\").concat(option, \"] is deprecated and will be removed in a later version.\");\n}\n\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  var optionsWarned = new Set();\n\n  function deprecated() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var options = args[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this).apply(void 0, args); // call the function, no change\n    } // interrupt the function call with a warning\n\n\n    var _iterator = _createForOfIteratorHelper(config.deprecatedOptions),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var deprecatedOption = _step.value;\n\n        if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n          optionsWarned.add(deprecatedOption);\n          var msg = msgHandler(config.name, deprecatedOption);\n          emitWarning(msg);\n\n          if (this && 'getLogger' in this) {\n            var logger = this.getLogger();\n\n            if (logger) {\n              logger.warn(msg);\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return fn.bind(this).apply(void 0, args);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nvar MongoDBNamespace = /*#__PURE__*/function () {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  function MongoDBNamespace(db, collection) {\n    _classCallCheck(this, MongoDBNamespace);\n\n    this.db = db;\n    this.collection = collection;\n  }\n\n  _createClass(MongoDBNamespace, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.collection ? \"\".concat(this.db, \".\").concat(this.collection) : this.db;\n    }\n  }, {\n    key: \"withCollection\",\n    value: function withCollection(collection) {\n      return new MongoDBNamespace(this.db, collection);\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(namespace) {\n      if (!namespace) {\n        // TODO(NODE-3483): Replace with MongoNamespaceError\n        throw new error_1.MongoRuntimeError(\"Cannot parse namespace from \\\"\".concat(namespace, \"\\\"\"));\n      }\n\n      var _namespace$split = namespace.split('.'),\n          _namespace$split2 = _toArray(_namespace$split),\n          db = _namespace$split2[0],\n          collection = _namespace$split2.slice(1);\n\n      return new MongoDBNamespace(db, collection.join('.'));\n    }\n  }]);\n\n  return MongoDBNamespace;\n}();\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction makeCounter() {\n  var seed,\n      count,\n      newCount,\n      _args = arguments;\n  return _regeneratorRuntime().wrap(function makeCounter$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;\n          count = seed;\n\n        case 2:\n          if (!true) {\n            _context.next = 9;\n            break;\n          }\n\n          newCount = count;\n          count += 1;\n          _context.next = 7;\n          return newCount;\n\n        case 7:\n          _context.next = 2;\n          break;\n\n        case 9:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\n\nfunction maybePromise(callback, wrapper) {\n  var Promise = promise_provider_1.PromiseProvider.get();\n  var result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise(function (resolve, reject) {\n      callback = function callback(err, res) {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  wrapper(function (err, res) {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err);\n      } catch (error) {\n        process.nextTick(function () {\n          throw error;\n        });\n      }\n\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    callback(err, res);\n  });\n  return result;\n}\n\nexports.maybePromise = maybePromise;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  var result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      var lastHello = topologyOrServer.lastHello();\n\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  var idx = 0;\n  var awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  var idx = 0;\n  var awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every(function (elt, idx) {\n    return elt === arr2[idx];\n  });\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    var legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(\"illegal state transition from [\".concat(target.s.state, \"] => [\").concat(newState, \"], allowed: [\").concat(legalStates, \"]\"));\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nvar NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  var metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: \"Node.js \".concat(process.version, \", \").concat(os.endianness(), \" (unified)\")\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = \"\".concat(metadata.driver.name, \"|\").concat(options.driverInfo.name);\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = \"\".concat(metadata.driver.version, \"|\").concat(options.driverInfo.version);\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = \"\".concat(metadata.platform, \"|\").concat(options.driverInfo.platform);\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    var buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  var hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  var elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\n\nfunction makeInterruptibleAsyncInterval(fn, options) {\n  var timerId;\n  var lastCallTime;\n  var cannotBeExpedited = false;\n  var stopped = false;\n  options = options !== null && options !== void 0 ? options : {};\n  var interval = options.interval || 1000;\n  var minInterval = options.minInterval || 500;\n  var immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  var clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    var currentTime = clock();\n    var nextScheduledCallTime = lastCallTime + interval;\n    var timeUntilNextCall = nextScheduledCallTime - currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n      return;\n    } // debounce multiple calls to wake within the `minInterval`\n\n\n    if (cannotBeExpedited) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n      cannotBeExpedited = true;\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = undefined;\n    }\n\n    lastCallTime = 0;\n    cannotBeExpedited = false;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n\n    timerId = (0, timers_1.setTimeout)(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    cannotBeExpedited = false;\n    lastCallTime = clock();\n    fn(function (err) {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n\n  return {\n    wake: wake,\n    stop: stop\n  };\n}\n\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    var _iterator2 = _createForOfIteratorHelper(doc),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var document = _step2.value;\n\n        if (hasAtomicOperators(document)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return false;\n  }\n\n  var keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n\n  var result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  var session = options === null || options === void 0 ? void 0 : options.session;\n\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    var readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    var writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  var readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  var _iterator3 = _createForOfIteratorHelper(subset),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var elem = _step3.value;\n\n      if (!set.has(elem)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\n\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\n\nfunction setDifference(setA, setB) {\n  var difference = new Set(setA);\n\n  var _iterator4 = _createForOfIteratorHelper(setB),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var elem = _step4.value;\n      difference.delete(elem);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nvar HAS_OWN = function HAS_OWN(object, prop) {\n  return Object.prototype.hasOwnProperty.call(object, prop);\n};\n\nfunction isRecord(value) {\n  var requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  var ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    var keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(function (item) {\n      return deepCopy(item);\n    });\n  } else if (isRecord(value)) {\n    var res = {};\n\n    for (var key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  var ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/** @internal */\n\nvar kBuffers = Symbol('buffers');\n/** @internal */\n\nvar kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nvar BufferPool = /*#__PURE__*/function () {\n  function BufferPool() {\n    _classCallCheck(this, BufferPool);\n\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n\n  _createClass(BufferPool, [{\n    key: \"length\",\n    get: function get() {\n      return this[kLength];\n    }\n    /** Adds a buffer to the internal buffer pool list */\n\n  }, {\n    key: \"append\",\n    value: function append(buffer) {\n      this[kBuffers].push(buffer);\n      this[kLength] += buffer.length;\n    }\n    /** Returns the requested number of bytes without consuming them */\n\n  }, {\n    key: \"peek\",\n    value: function peek(size) {\n      return this.read(size, false);\n    }\n    /** Reads the requested number of bytes, optionally consuming them */\n\n  }, {\n    key: \"read\",\n    value: function read(size) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (typeof size !== 'number' || size < 0) {\n        throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n      }\n\n      if (size > this[kLength]) {\n        return Buffer.alloc(0);\n      }\n\n      var result; // read the whole buffer\n\n      if (size === this.length) {\n        result = Buffer.concat(this[kBuffers]);\n\n        if (consume) {\n          this[kBuffers] = [];\n          this[kLength] = 0;\n        }\n      } // size is within first buffer, no need to concat\n      else if (size <= this[kBuffers][0].length) {\n        result = this[kBuffers][0].slice(0, size);\n\n        if (consume) {\n          this[kBuffers][0] = this[kBuffers][0].slice(size);\n          this[kLength] -= size;\n        }\n      } // size is beyond first buffer, need to track and copy\n      else {\n        result = Buffer.allocUnsafe(size);\n        var idx;\n        var offset = 0;\n        var bytesToCopy = size;\n\n        for (idx = 0; idx < this[kBuffers].length; ++idx) {\n          var bytesCopied = void 0;\n\n          if (bytesToCopy > this[kBuffers][idx].length) {\n            bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n            offset += bytesCopied;\n          } else {\n            bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n\n            if (consume) {\n              this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n            }\n\n            offset += bytesCopied;\n            break;\n          }\n\n          bytesToCopy -= bytesCopied;\n        } // compact the internal buffer array\n\n\n        if (consume) {\n          this[kBuffers] = this[kBuffers].slice(idx);\n          this[kLength] -= size;\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return BufferPool;\n}();\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nvar HostAddress = /*#__PURE__*/function (_Symbol$for) {\n  function HostAddress(hostString) {\n    _classCallCheck(this, HostAddress);\n\n    var escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    var _url_1$URL = new url_1.URL(\"mongodb://\".concat(escapedHost)),\n        hostname = _url_1$URL.hostname,\n        port = _url_1$URL.port;\n\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n      var normalized = decodeURIComponent(hostname).toLowerCase();\n\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n\n      this.host = normalized.toLowerCase();\n\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n\n      if (this.port === 0) {\n        throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n\n    Object.freeze(this);\n  }\n\n  _createClass(HostAddress, [{\n    key: _Symbol$for,\n    value: function value() {\n      return this.inspect();\n    }\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return \"new HostAddress('\".concat(this.toString(true), \"')\");\n    }\n    /**\n     * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var ipv6Brackets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (typeof this.host === 'string') {\n        if (this.isIPv6 && ipv6Brackets) {\n          return \"[\".concat(this.host, \"]:\").concat(this.port);\n        }\n\n        return \"\".concat(this.host, \":\").concat(this.port);\n      }\n\n      return \"\".concat(this.socketPath);\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(s) {\n      return new HostAddress(s);\n    }\n  }, {\n    key: \"fromHostPort\",\n    value: function fromHostPort(host, port) {\n      if (host.includes(':')) {\n        host = \"[\".concat(host, \"]\"); // IPv6 address\n      }\n\n      return HostAddress.fromString(\"\".concat(host, \":\").concat(port));\n    }\n  }, {\n    key: \"fromSrvRecord\",\n    value: function fromSrvRecord(_ref3) {\n      var name = _ref3.name,\n          port = _ref3.port;\n      return HostAddress.fromHostPort(name, port);\n    }\n  }]);\n\n  return HostAddress;\n}(Symbol.for('nodejs.util.inspect.custom'));\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk: function createPk() {\n    return new bson_1.ObjectId();\n  }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nvar emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n\nfunction parsePackageVersion(_ref4) {\n  var version = _ref4.version;\n\n  var _version$split$map = version.split('.').map(function (n) {\n    return Number.parseInt(n, 10);\n  }),\n      _version$split$map2 = _slicedToArray(_version$split$map, 3),\n      major = _version$split$map2[0],\n      minor = _version$split$map2[1],\n      patch = _version$split$map2[2];\n\n  return {\n    major: major,\n    minor: minor,\n    patch: patch\n  };\n}\n\nexports.parsePackageVersion = parsePackageVersion;\n/**\n * FisherYates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\n\nfunction shuffle(sequence) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  var remainingItemsToShuffle = items.length;\n  var lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    var randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1; // And swap it with the current element\n\n    var swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\nexports.shuffle = shuffle; // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/**\n * A utility function to get the instance of mongodb-client-encryption, if it exists.\n *\n * @throws MongoMissingDependencyError if mongodb-client-encryption isn't installed.\n * @returns\n */\n\nfunction getMongoDBClientEncryption() {\n  var mongodbClientEncryption; // NOTE(NODE-4254): This is to get around the circular dependency between\n  // mongodb-client-encryption and the driver in the test scenarios.\n\n  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n    mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n  } else {\n    mongodbClientEncryption = require('mongodb-client-encryption');\n  }\n\n  return mongodbClientEncryption;\n}\n\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;","map":null,"metadata":{},"sourceType":"script"}