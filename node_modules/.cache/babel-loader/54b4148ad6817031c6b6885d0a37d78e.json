{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _get = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\n\nvar bson_1 = require(\"../bson\");\n\nvar error_1 = require(\"../error\");\n\nvar read_preference_1 = require(\"../read_preference\");\n\nvar utils_1 = require(\"../utils\");\n\nvar command_1 = require(\"./command\");\n\nvar operation_1 = require(\"./operation\");\n\nvar exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\n\nvar MapReduceOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(MapReduceOperation, _command_1$CommandOpe);\n\n  var _super = _createSuper(MapReduceOperation);\n\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  function MapReduceOperation(collection, map, reduce, options) {\n    var _this;\n\n    _classCallCheck(this, MapReduceOperation);\n\n    _this = _super.call(this, collection, options);\n    _this.options = options !== null && options !== void 0 ? options : {};\n    _this.collection = collection;\n    _this.map = map;\n    _this.reduce = reduce;\n    return _this;\n  }\n\n  _createClass(MapReduceOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this2 = this;\n\n      var coll = this.collection;\n      var map = this.map;\n      var reduce = this.reduce;\n      var options = this.options;\n      var mapCommandHash = {\n        mapReduce: coll.collectionName,\n        map: map,\n        reduce: reduce\n      };\n\n      if (options.scope) {\n        mapCommandHash.scope = processScope(options.scope);\n      } // Add any other options passed in\n\n\n      for (var n in options) {\n        // Only include if not in exclusion list\n        if (exclusionList.indexOf(n) === -1) {\n          mapCommandHash[n] = options[n];\n        }\n      }\n\n      options = Object.assign({}, options); // If we have a read preference and inline is not set as output fail hard\n\n      if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n        // Force readPreference to primary\n        options.readPreference = read_preference_1.ReadPreference.primary; // Decorate command with writeConcern if supported\n\n        (0, utils_1.applyWriteConcern)(mapCommandHash, {\n          db: coll.s.db,\n          collection: coll\n        }, options);\n      } else {\n        (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n      } // Is bypassDocumentValidation specified\n\n\n      if (options.bypassDocumentValidation === true) {\n        mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n      } // Have we specified collation\n\n\n      try {\n        (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n      } catch (err) {\n        return callback(err);\n      }\n\n      if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n        callback(new error_1.MongoCompatibilityError(\"Server \".concat(server.name, \" does not support explain on mapReduce\")));\n        return;\n      } // Execute command\n\n\n      _get(_getPrototypeOf(MapReduceOperation.prototype), \"executeCommand\", this).call(this, server, session, mapCommandHash, function (err, result) {\n        if (err) return callback(err); // Check if we have an error\n\n        if (1 !== result.ok || result.err || result.errmsg) {\n          return callback(new error_1.MongoServerError(result));\n        } // If an explain option was executed, don't process the server results\n\n\n        if (_this2.explain) return callback(undefined, result); // Create statistics value\n\n        var stats = {};\n        if (result.timeMillis) stats['processtime'] = result.timeMillis;\n        if (result.counts) stats['counts'] = result.counts;\n        if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n        if (result.results) {\n          // If we wish for no verbosity\n          if (options['verbose'] == null || !options['verbose']) {\n            return callback(undefined, result.results);\n          }\n\n          return callback(undefined, {\n            results: result.results,\n            stats: stats\n          });\n        } // The returned collection\n\n\n        var collection = null; // If we have an object it's a different db\n\n        if (result.result != null && typeof result.result === 'object') {\n          var doc = result.result; // Return a collection from another db\n\n          collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n        } else {\n          // Create a collection object that wraps the result collection\n          collection = coll.s.db.collection(result.result);\n        } // If we wish for no verbosity\n\n\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(err, collection);\n        } // Return stats as third set of values\n\n\n        callback(err, {\n          collection: collection,\n          stats: stats\n        });\n      });\n    }\n  }]);\n\n  return MapReduceOperation;\n}(command_1.CommandOperation);\n\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\n\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  var newScope = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(scope); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n\n  return newScope;\n}\n\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":null,"metadata":{},"sourceType":"script"}