{"ast":null,"code":"\"use strict\";\n\nvar _get = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\n\nvar error_1 = require(\"../error\");\n\nvar read_preference_1 = require(\"../read_preference\");\n\nvar utils_1 = require(\"../utils\");\n\nvar command_1 = require(\"./command\");\n\nvar common_functions_1 = require(\"./common_functions\");\n\nvar operation_1 = require(\"./operation\");\n\nvar VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nfunction makeIndexSpec(indexSpec, options) {\n  var indexParameters = (0, utils_1.parseIndexOptions)(indexSpec); // Generate the index name\n\n  var name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  var finalIndexSpec = {\n    name: name,\n    key: indexParameters.fieldHash\n  }; // merge valid index options into the index spec\n\n  for (var optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec;\n}\n/** @internal */\n\n\nvar IndexesOperation = /*#__PURE__*/function (_operation_1$Abstract) {\n  _inherits(IndexesOperation, _operation_1$Abstract);\n\n  var _super = _createSuper(IndexesOperation);\n\n  function IndexesOperation(collection, options) {\n    var _this;\n\n    _classCallCheck(this, IndexesOperation);\n\n    _this = _super.call(this, options);\n    _this.options = options;\n    _this.collection = collection;\n    return _this;\n  }\n\n  _createClass(IndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var coll = this.collection;\n      var options = this.options;\n      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread(_objectSpread({\n        full: true\n      }, options), {}, {\n        readPreference: this.readPreference,\n        session: session\n      }), callback);\n    }\n  }]);\n\n  return IndexesOperation;\n}(operation_1.AbstractOperation);\n\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\n\nvar CreateIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(CreateIndexesOperation, _command_1$CommandOpe);\n\n  var _super2 = _createSuper(CreateIndexesOperation);\n\n  function CreateIndexesOperation(parent, collectionName, indexes, options) {\n    var _this2;\n\n    _classCallCheck(this, CreateIndexesOperation);\n\n    _this2 = _super2.call(this, parent, options);\n    _this2.options = options !== null && options !== void 0 ? options : {};\n    _this2.collectionName = collectionName;\n    _this2.indexes = indexes;\n    return _this2;\n  }\n\n  _createClass(CreateIndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var options = this.options;\n      var indexes = this.indexes;\n      var serverWireVersion = (0, utils_1.maxWireVersion)(server); // Ensure we generate the correct name if the parameter is not set\n\n      for (var i = 0; i < indexes.length; i++) {\n        // Did the user pass in a collation, check if our write server supports it\n        if (indexes[i].collation && serverWireVersion < 5) {\n          callback(new error_1.MongoCompatibilityError(\"Server \".concat(server.name, \", which reports wire version \").concat(serverWireVersion, \", \") + 'does not support collation'));\n          return;\n        }\n\n        if (indexes[i].name == null) {\n          var keys = [];\n\n          for (var name in indexes[i].key) {\n            keys.push(\"\".concat(name, \"_\").concat(indexes[i].key[name]));\n          } // Set the name\n\n\n          indexes[i].name = keys.join('_');\n        }\n      }\n\n      var cmd = {\n        createIndexes: this.collectionName,\n        indexes: indexes\n      };\n\n      if (options.commitQuorum != null) {\n        if (serverWireVersion < 9) {\n          callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n          return;\n        }\n\n        cmd.commitQuorum = options.commitQuorum;\n      } // collation is set on each index, it should not be defined at the root\n\n\n      this.options.collation = undefined;\n\n      _get(_getPrototypeOf(CreateIndexesOperation.prototype), \"executeCommand\", this).call(this, server, session, cmd, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        var indexNames = indexes.map(function (index) {\n          return index.name || '';\n        });\n        callback(undefined, indexNames);\n      });\n    }\n  }]);\n\n  return CreateIndexesOperation;\n}(command_1.CommandOperation);\n\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\n\nvar CreateIndexOperation = /*#__PURE__*/function (_CreateIndexesOperati) {\n  _inherits(CreateIndexOperation, _CreateIndexesOperati);\n\n  var _super3 = _createSuper(CreateIndexOperation);\n\n  function CreateIndexOperation(parent, collectionName, indexSpec, options) {\n    _classCallCheck(this, CreateIndexOperation);\n\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    return _super3.call(this, parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n\n  _createClass(CreateIndexOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      _get(_getPrototypeOf(CreateIndexOperation.prototype), \"execute\", this).call(this, server, session, function (err, indexNames) {\n        if (err || !indexNames) return callback(err);\n        return callback(undefined, indexNames[0]);\n      });\n    }\n  }]);\n\n  return CreateIndexOperation;\n}(CreateIndexesOperation);\n\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\n\nvar EnsureIndexOperation = /*#__PURE__*/function (_CreateIndexOperation) {\n  _inherits(EnsureIndexOperation, _CreateIndexOperation);\n\n  var _super4 = _createSuper(EnsureIndexOperation);\n\n  function EnsureIndexOperation(db, collectionName, indexSpec, options) {\n    var _this3;\n\n    _classCallCheck(this, EnsureIndexOperation);\n\n    _this3 = _super4.call(this, db, collectionName, indexSpec, options);\n    _this3.readPreference = read_preference_1.ReadPreference.primary;\n    _this3.db = db;\n    _this3.collectionName = collectionName;\n    return _this3;\n  }\n\n  _createClass(EnsureIndexOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this4 = this;\n\n      var indexName = this.indexes[0].name;\n      var cursor = this.db.collection(this.collectionName).listIndexes({\n        session: session\n      });\n      cursor.toArray(function (err, indexes) {\n        /// ignore \"NamespaceNotFound\" errors\n        if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n          return callback(err);\n        }\n\n        if (indexes) {\n          indexes = Array.isArray(indexes) ? indexes : [indexes];\n\n          if (indexes.some(function (index) {\n            return index.name === indexName;\n          })) {\n            callback(undefined, indexName);\n            return;\n          }\n        }\n\n        _get(_getPrototypeOf(EnsureIndexOperation.prototype), \"execute\", _this4).call(_this4, server, session, callback);\n      });\n    }\n  }]);\n\n  return EnsureIndexOperation;\n}(CreateIndexOperation);\n\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\n\nvar DropIndexOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {\n  _inherits(DropIndexOperation, _command_1$CommandOpe2);\n\n  var _super5 = _createSuper(DropIndexOperation);\n\n  function DropIndexOperation(collection, indexName, options) {\n    var _this5;\n\n    _classCallCheck(this, DropIndexOperation);\n\n    _this5 = _super5.call(this, collection, options);\n    _this5.options = options !== null && options !== void 0 ? options : {};\n    _this5.collection = collection;\n    _this5.indexName = indexName;\n    return _this5;\n  }\n\n  _createClass(DropIndexOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var cmd = {\n        dropIndexes: this.collection.collectionName,\n        index: this.indexName\n      };\n\n      _get(_getPrototypeOf(DropIndexOperation.prototype), \"executeCommand\", this).call(this, server, session, cmd, callback);\n    }\n  }]);\n\n  return DropIndexOperation;\n}(command_1.CommandOperation);\n\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\n\nvar DropIndexesOperation = /*#__PURE__*/function (_DropIndexOperation) {\n  _inherits(DropIndexesOperation, _DropIndexOperation);\n\n  var _super6 = _createSuper(DropIndexesOperation);\n\n  function DropIndexesOperation(collection, options) {\n    _classCallCheck(this, DropIndexesOperation);\n\n    return _super6.call(this, collection, '*', options);\n  }\n\n  _createClass(DropIndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      _get(_getPrototypeOf(DropIndexesOperation.prototype), \"execute\", this).call(this, server, session, function (err) {\n        if (err) return callback(err, false);\n        callback(undefined, true);\n      });\n    }\n  }]);\n\n  return DropIndexesOperation;\n}(DropIndexOperation);\n\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\n\nvar ListIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe3) {\n  _inherits(ListIndexesOperation, _command_1$CommandOpe3);\n\n  var _super7 = _createSuper(ListIndexesOperation);\n\n  function ListIndexesOperation(collection, options) {\n    var _this6;\n\n    _classCallCheck(this, ListIndexesOperation);\n\n    _this6 = _super7.call(this, collection, options);\n    _this6.options = options !== null && options !== void 0 ? options : {};\n    _this6.collectionNamespace = collection.s.namespace;\n    return _this6;\n  }\n\n  _createClass(ListIndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var serverWireVersion = (0, utils_1.maxWireVersion)(server);\n      var cursor = this.options.batchSize ? {\n        batchSize: this.options.batchSize\n      } : {};\n      var command = {\n        listIndexes: this.collectionNamespace.collection,\n        cursor: cursor\n      }; // we check for undefined specifically here to allow falsy values\n      // eslint-disable-next-line no-restricted-syntax\n\n      if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n        command.comment = this.options.comment;\n      }\n\n      _get(_getPrototypeOf(ListIndexesOperation.prototype), \"executeCommand\", this).call(this, server, session, command, callback);\n    }\n  }]);\n\n  return ListIndexesOperation;\n}(command_1.CommandOperation);\n\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\n\nvar IndexExistsOperation = /*#__PURE__*/function (_operation_1$Abstract2) {\n  _inherits(IndexExistsOperation, _operation_1$Abstract2);\n\n  var _super8 = _createSuper(IndexExistsOperation);\n\n  function IndexExistsOperation(collection, indexes, options) {\n    var _this7;\n\n    _classCallCheck(this, IndexExistsOperation);\n\n    _this7 = _super8.call(this, options);\n    _this7.options = options;\n    _this7.collection = collection;\n    _this7.indexes = indexes;\n    return _this7;\n  }\n\n  _createClass(IndexExistsOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var coll = this.collection;\n      var indexes = this.indexes;\n      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread(_objectSpread({}, this.options), {}, {\n        readPreference: this.readPreference,\n        session: session\n      }), function (err, indexInformation) {\n        // If we have an error return\n        if (err != null) return callback(err); // Let's check for the index names\n\n        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes\n\n        for (var i = 0; i < indexes.length; i++) {\n          if (indexInformation[indexes[i]] == null) {\n            return callback(undefined, false);\n          }\n        } // All keys found return true\n\n\n        return callback(undefined, true);\n      });\n    }\n  }]);\n\n  return IndexExistsOperation;\n}(operation_1.AbstractOperation);\n\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\n\nvar IndexInformationOperation = /*#__PURE__*/function (_operation_1$Abstract3) {\n  _inherits(IndexInformationOperation, _operation_1$Abstract3);\n\n  var _super9 = _createSuper(IndexInformationOperation);\n\n  function IndexInformationOperation(db, name, options) {\n    var _this8;\n\n    _classCallCheck(this, IndexInformationOperation);\n\n    _this8 = _super9.call(this, options);\n    _this8.options = options !== null && options !== void 0 ? options : {};\n    _this8.db = db;\n    _this8.name = name;\n    return _this8;\n  }\n\n  _createClass(IndexInformationOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var db = this.db;\n      var name = this.name;\n      (0, common_functions_1.indexInformation)(db, name, _objectSpread(_objectSpread({}, this.options), {}, {\n        readPreference: this.readPreference,\n        session: session\n      }), callback);\n    }\n  }]);\n\n  return IndexInformationOperation;\n}(operation_1.AbstractOperation);\n\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":null,"metadata":{},"sourceType":"script"}