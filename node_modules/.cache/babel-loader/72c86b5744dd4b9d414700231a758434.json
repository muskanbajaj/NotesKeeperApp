{"ast":null,"code":"\"use strict\";\n\nvar _get = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\n\nvar timers_1 = require(\"timers\");\n\nvar bson_1 = require(\"../bson\");\n\nvar constants_1 = require(\"../constants\");\n\nvar error_1 = require(\"../error\");\n\nvar mongo_types_1 = require(\"../mongo_types\");\n\nvar sessions_1 = require(\"../sessions\");\n\nvar utils_1 = require(\"../utils\");\n\nvar command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nvar commands_1 = require(\"./commands\");\n\nvar message_stream_1 = require(\"./message_stream\");\n\nvar stream_description_1 = require(\"./stream_description\");\n\nvar shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\n\n\nvar kStream = Symbol('stream');\n/** @internal */\n\nvar kQueue = Symbol('queue');\n/** @internal */\n\nvar kMessageStream = Symbol('messageStream');\n/** @internal */\n\nvar kGeneration = Symbol('generation');\n/** @internal */\n\nvar kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nvar kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nvar kDescription = Symbol('description');\n/** @internal */\n\nvar kHello = Symbol('hello');\n/** @internal */\n\nvar kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nvar kFullResult = Symbol('fullResult');\n/** @internal */\n\nvar kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\n\nvar Connection = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Connection, _mongo_types_1$TypedE);\n\n  var _super = _createSuper(Connection);\n\n  function Connection(stream, options) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    var _a, _b;\n\n    _this = _super.call(this);\n    _this.id = options.id;\n    _this.address = streamIdentifier(stream, options);\n    _this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    _this.monitorCommands = options.monitorCommands;\n    _this.serverApi = options.serverApi;\n    _this.closed = false;\n    _this.destroyed = false;\n    _this[kHello] = null;\n    _this[kClusterTime] = null;\n    _this[kDescription] = new stream_description_1.StreamDescription(_this.address, options);\n    _this[kGeneration] = options.generation;\n    _this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling\n\n    _this[kQueue] = new Map();\n    _this[kMessageStream] = new message_stream_1.MessageStream(_objectSpread(_objectSpread({}, options), {}, {\n      maxBsonMessageSize: (_b = _this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    }));\n    _this[kStream] = stream;\n    _this[kDelayedTimeoutId] = null;\n\n    _this[kMessageStream].on('message', function (message) {\n      return _this.onMessage(message);\n    });\n\n    _this[kMessageStream].on('error', function (error) {\n      return _this.onError(error);\n    });\n\n    _this[kStream].on('close', function () {\n      return _this.onClose();\n    });\n\n    _this[kStream].on('timeout', function () {\n      return _this.onTimeout();\n    });\n\n    _this[kStream].on('error', function () {\n      /* ignore errors, listen to `close` instead */\n    }); // hook the message stream up to the passed in stream\n\n\n    _this[kStream].pipe(_this[kMessageStream]);\n\n    _this[kMessageStream].pipe(_this[kStream]);\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"description\",\n    get: function get() {\n      return this[kDescription];\n    }\n  }, {\n    key: \"hello\",\n    get: function get() {\n      return this[kHello];\n    } // the `connect` method stores the result of the handshake hello on the connection\n    ,\n    set: function set(response) {\n      this[kDescription].receiveResponse(response);\n      this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n      this[kHello] = response;\n    } // Set the whether the message stream is for a monitoring connection.\n\n  }, {\n    key: \"isMonitoringConnection\",\n    get: function get() {\n      return this[kMessageStream].isMonitoringConnection;\n    },\n    set: function set(value) {\n      this[kMessageStream].isMonitoringConnection = value;\n    }\n  }, {\n    key: \"serviceId\",\n    get: function get() {\n      var _a;\n\n      return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.description.loadBalanced;\n    }\n  }, {\n    key: \"generation\",\n    get: function get() {\n      return this[kGeneration] || 0;\n    },\n    set: function set(generation) {\n      this[kGeneration] = generation;\n    }\n  }, {\n    key: \"idleTime\",\n    get: function get() {\n      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this[kClusterTime];\n    }\n  }, {\n    key: \"stream\",\n    get: function get() {\n      return this[kStream];\n    }\n  }, {\n    key: \"markAvailable\",\n    value: function markAvailable() {\n      this[kLastUseTime] = (0, utils_1.now)();\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      if (this.closed) {\n        return;\n      }\n\n      this[kStream].destroy(error);\n      this.closed = true;\n\n      var _iterator = _createForOfIteratorHelper(this[kQueue].values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var op = _step.value;\n          op.cb(error);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      var message = \"connection \".concat(this.id, \" to \").concat(this.address, \" closed\");\n\n      var _iterator2 = _createForOfIteratorHelper(this[kQueue].values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var op = _step2.value;\n          op.cb(new error_1.MongoNetworkError(message));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }\n  }, {\n    key: \"onTimeout\",\n    value: function onTimeout() {\n      var _this2 = this;\n\n      if (this.closed) {\n        return;\n      }\n\n      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(function () {\n        _this2[kStream].destroy();\n\n        _this2.closed = true;\n        var message = \"connection \".concat(_this2.id, \" to \").concat(_this2.address, \" timed out\");\n        var beforeHandshake = _this2.hello == null;\n\n        var _iterator3 = _createForOfIteratorHelper(_this2[kQueue].values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var op = _step3.value;\n            op.cb(new error_1.MongoNetworkTimeoutError(message, {\n              beforeHandshake: beforeHandshake\n            }));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        _this2[kQueue].clear();\n\n        _this2.emit(Connection.CLOSE);\n      }, 1).unref(); // No need for this timer to hold the event loop open\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(message) {\n      var delayedTimeoutId = this[kDelayedTimeoutId];\n\n      if (delayedTimeoutId != null) {\n        clearTimeout(delayedTimeoutId);\n        this[kDelayedTimeoutId] = null;\n      } // always emit the message, in case we are streaming\n\n\n      this.emit('message', message);\n      var operationDescription = this[kQueue].get(message.responseTo);\n\n      if (!operationDescription) {\n        return;\n      }\n\n      var callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n      // track response, however the server currently synthetically produces remote requests\n      // making the `responseTo` change on each response\n\n      this[kQueue].delete(message.responseTo);\n\n      if ('moreToCome' in message && message.moreToCome) {\n        // requeue the callback for next synthetic request\n        this[kQueue].set(message.requestId, operationDescription);\n      } else if (operationDescription.socketTimeoutOverride) {\n        this[kStream].setTimeout(this.socketTimeoutMS);\n      }\n\n      try {\n        // Pass in the entire description because it has BSON parsing options\n        message.parse(operationDescription);\n      } catch (err) {\n        // If this error is generated by our own code, it will already have the correct class applied\n        // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n        // in either case, it should not be wrapped\n        callback(err);\n        return;\n      }\n\n      if (message.documents[0]) {\n        var document = message.documents[0];\n        var session = operationDescription.session;\n\n        if (session) {\n          (0, sessions_1.updateSessionFromResponse)(session, document);\n        }\n\n        if (document.$clusterTime) {\n          this[kClusterTime] = document.$clusterTime;\n          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n        }\n\n        if (operationDescription.command) {\n          if (document.writeConcernError) {\n            callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n            return;\n          }\n\n          if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n            callback(new error_1.MongoServerError(document));\n            return;\n          }\n        } else {\n          // Pre 3.2 support\n          if (document.ok === 0 || document.$err || document.errmsg) {\n            callback(new error_1.MongoServerError(document));\n            return;\n          }\n        }\n      }\n\n      callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {\n          force: false\n        };\n      }\n\n      this.removeAllListeners(Connection.PINNED);\n      this.removeAllListeners(Connection.UNPINNED);\n      options = Object.assign({\n        force: false\n      }, options);\n\n      if (this[kStream] == null || this.destroyed) {\n        this.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      if (options.force) {\n        this[kStream].destroy();\n        this.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      this[kStream].end(function () {\n        _this3.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n    }\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      if (!(ns instanceof utils_1.MongoDBNamespace)) {\n        // TODO(NODE-3483): Replace this with a MongoCommandError\n        throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n      }\n\n      var readPreference = (0, shared_1.getReadPreference)(cmd, options);\n      var shouldUseOpMsg = supportsOpMsg(this);\n      var session = options === null || options === void 0 ? void 0 : options.session;\n      var clusterTime = this.clusterTime;\n      var finalCmd = Object.assign({}, cmd);\n\n      if (this.serverApi) {\n        var _this$serverApi = this.serverApi,\n            version = _this$serverApi.version,\n            strict = _this$serverApi.strict,\n            deprecationErrors = _this$serverApi.deprecationErrors;\n        finalCmd.apiVersion = version;\n        if (strict != null) finalCmd.apiStrict = strict;\n        if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n      }\n\n      if (hasSessionSupport(this) && session) {\n        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n          clusterTime = session.clusterTime;\n        }\n\n        var err = (0, sessions_1.applySession)(session, finalCmd, options);\n\n        if (err) {\n          return callback(err);\n        }\n      } // if we have a known cluster time, gossip it\n\n\n      if (clusterTime) {\n        finalCmd.$clusterTime = clusterTime;\n      }\n\n      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n        finalCmd = {\n          $query: finalCmd,\n          $readPreference: readPreference.toJSON()\n        };\n      }\n\n      var commandOptions = Object.assign({\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      }, options);\n      var cmdNs = \"\".concat(ns.db, \".$cmd\");\n      var message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n      try {\n        write(this, message, commandOptions, callback);\n      } catch (err) {\n        callback(err);\n      }\n    }\n  }, {\n    key: \"getMore\",\n    value: function getMore(ns, cursorId, options, callback) {\n      var fullResult = !!options[kFullResult];\n      var wireVersion = (0, utils_1.maxWireVersion)(this);\n\n      if (!cursorId) {\n        // TODO(NODE-3483): Replace this with a MongoCommandError\n        callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n        return;\n      }\n\n      if (wireVersion < 4) {\n        var getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n          numberToReturn: options.batchSize\n        });\n        var queryOptions = (0, shared_1.applyCommonQueryOptions)({}, Object.assign(options, _objectSpread({}, (0, bson_1.pluckBSONSerializeOptions)(options))));\n        queryOptions[kFullResult] = true;\n        queryOptions.command = true;\n        write(this, getMoreOp, queryOptions, function (err, response) {\n          if (fullResult) return callback(err, response);\n          if (err) return callback(err);\n          callback(undefined, {\n            cursor: {\n              id: response.cursorId,\n              nextBatch: response.documents\n            }\n          });\n        });\n        return;\n      }\n\n      var getMoreCmd = {\n        getMore: cursorId,\n        collection: ns.collection\n      };\n\n      if (typeof options.batchSize === 'number') {\n        getMoreCmd.batchSize = Math.abs(options.batchSize);\n      }\n\n      if (typeof options.maxAwaitTimeMS === 'number') {\n        getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n      } // we check for undefined specifically here to allow falsy values\n      // eslint-disable-next-line no-restricted-syntax\n\n\n      if (options.comment !== undefined) {\n        getMoreCmd.comment = options.comment;\n      }\n\n      var commandOptions = Object.assign({\n        returnFieldSelector: null,\n        documentsReturnedIn: 'nextBatch'\n      }, options);\n      this.command(ns, getMoreCmd, commandOptions, callback);\n    }\n  }, {\n    key: \"killCursors\",\n    value: function killCursors(ns, cursorIds, options, callback) {\n      if (!cursorIds || !Array.isArray(cursorIds)) {\n        // TODO(NODE-3483): Replace this with a MongoCommandError\n        throw new error_1.MongoRuntimeError(\"Invalid list of cursor ids provided: \".concat(cursorIds));\n      }\n\n      if ((0, utils_1.maxWireVersion)(this) < 4) {\n        try {\n          write(this, new commands_1.KillCursor(ns.toString(), cursorIds), _objectSpread({\n            noResponse: true\n          }, options), callback);\n        } catch (err) {\n          callback(err);\n        }\n\n        return;\n      }\n\n      this.command(ns, {\n        killCursors: ns.collection,\n        cursors: cursorIds\n      }, _objectSpread(_defineProperty({}, kFullResult, true), options), function (err, response) {\n        if (err || !response) return callback(err);\n\n        if (response.cursorNotFound) {\n          return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n        }\n\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\n          return callback( // TODO(NODE-3483)\n          new error_1.MongoRuntimeError(\"invalid killCursors result returned for cursor id \".concat(cursorIds[0])));\n        }\n\n        callback(undefined, response.documents[0]);\n      });\n    }\n  }]);\n\n  return Connection;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\n\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\n\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\n\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\n\nConnection.PINNED = constants_1.PINNED;\n/** @event */\n\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\n\nvar CryptoConnection = /*#__PURE__*/function (_Connection) {\n  _inherits(CryptoConnection, _Connection);\n\n  var _super2 = _createSuper(CryptoConnection);\n\n  function CryptoConnection(stream, options) {\n    var _this4;\n\n    _classCallCheck(this, CryptoConnection);\n\n    _this4 = _super2.call(this, stream, options);\n    _this4[kAutoEncrypter] = options.autoEncrypter;\n    return _this4;\n  }\n  /** @internal @override */\n\n\n  _createClass(CryptoConnection, [{\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      var _this5 = this;\n\n      var autoEncrypter = this[kAutoEncrypter];\n\n      if (!autoEncrypter) {\n        return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n      }\n\n      var serverWireVersion = (0, utils_1.maxWireVersion)(this);\n\n      if (serverWireVersion === 0) {\n        // This means the initial handshake hasn't happened yet\n        return _get(_getPrototypeOf(CryptoConnection.prototype), \"command\", this).call(this, ns, cmd, options, callback);\n      }\n\n      if (serverWireVersion < 8) {\n        callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n        return;\n      }\n\n      autoEncrypter.encrypt(ns.toString(), cmd, options, function (err, encrypted) {\n        if (err || encrypted == null) {\n          callback(err, null);\n          return;\n        }\n\n        _get(_getPrototypeOf(CryptoConnection.prototype), \"command\", _this5).call(_this5, ns, encrypted, options, function (err, response) {\n          if (err || response == null) {\n            callback(err, response);\n            return;\n          }\n\n          autoEncrypter.decrypt(response, options, callback);\n        });\n      });\n    }\n  }]);\n\n  return CryptoConnection;\n}(Connection);\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  var description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  var description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return \"\".concat(stream.remoteAddress, \":\").concat(stream.remotePort);\n  }\n\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  var operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n\n    operationDescription.cb = function (err, reply) {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}