{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _ref;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RTTPinger = exports.Monitor = void 0;\n\nvar timers_1 = require(\"timers\");\n\nvar bson_1 = require(\"../bson\");\n\nvar connect_1 = require(\"../cmap/connect\");\n\nvar connection_1 = require(\"../cmap/connection\");\n\nvar constants_1 = require(\"../constants\");\n\nvar error_1 = require(\"../error\");\n\nvar mongo_types_1 = require(\"../mongo_types\");\n\nvar utils_1 = require(\"../utils\");\n\nvar common_1 = require(\"./common\");\n\nvar events_1 = require(\"./events\");\n\nvar server_1 = require(\"./server\");\n/** @internal */\n\n\nvar kServer = Symbol('server');\n/** @internal */\n\nvar kMonitorId = Symbol('monitorId');\n/** @internal */\n\nvar kConnection = Symbol('connection');\n/** @internal */\n\nvar kCancellationToken = Symbol('cancellationToken');\n/** @internal */\n\nvar kRTTPinger = Symbol('rttPinger');\n/** @internal */\n\nvar kRoundTripTime = Symbol('roundTripTime');\nvar STATE_IDLE = 'idle';\nvar STATE_MONITORING = 'monitoring';\nvar stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, STATE_MONITORING]), _defineProperty(_ref, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING]), _defineProperty(_ref, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]), _ref));\nvar INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @internal */\n\n\nvar Monitor = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Monitor, _mongo_types_1$TypedE);\n\n  var _super = _createSuper(Monitor);\n\n  function Monitor(server, options) {\n    var _this;\n\n    _classCallCheck(this, Monitor);\n\n    var _a, _b, _c;\n\n    _this = _super.call(this);\n    _this[kServer] = server;\n    _this[kConnection] = undefined;\n    _this[kCancellationToken] = new mongo_types_1.CancellationToken();\n\n    _this[kCancellationToken].setMaxListeners(Infinity);\n\n    _this[kMonitorId] = undefined;\n    _this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    _this.address = server.description.address;\n    _this.options = Object.freeze({\n      connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,\n      heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,\n      minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500\n    });\n    var cancellationToken = _this[kCancellationToken]; // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    var connectOptions = Object.assign({\n      id: '<monitor>',\n      generation: server.s.pool.generation,\n      connectionType: connection_1.Connection,\n      cancellationToken: cancellationToken,\n      hostAddress: server.description.hostAddress\n    }, options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials;\n\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    _this.connectOptions = Object.freeze(connectOptions);\n    return _this;\n  }\n\n  _createClass(Monitor, [{\n    key: \"connection\",\n    get: function get() {\n      return this[kConnection];\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      if (this.s.state !== common_1.STATE_CLOSED) {\n        return;\n      } // start\n\n\n      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n      this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {\n        interval: heartbeatFrequencyMS,\n        minInterval: minHeartbeatFrequencyMS,\n        immediate: true\n      });\n    }\n  }, {\n    key: \"requestCheck\",\n    value: function requestCheck() {\n      var _a;\n\n      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n        return;\n      }\n\n      (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var topologyVersion = this[kServer].description.topologyVersion;\n\n      if (isInCloseState(this) || topologyVersion == null) {\n        return;\n      }\n\n      stateTransition(this, common_1.STATE_CLOSING);\n      resetMonitorState(this); // restart monitor\n\n      stateTransition(this, STATE_IDLE); // restart monitoring\n\n      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n      this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {\n        interval: heartbeatFrequencyMS,\n        minInterval: minHeartbeatFrequencyMS\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (isInCloseState(this)) {\n        return;\n      }\n\n      stateTransition(this, common_1.STATE_CLOSING);\n      resetMonitorState(this); // close monitor\n\n      this.emit('close');\n      stateTransition(this, common_1.STATE_CLOSED);\n    }\n  }]);\n\n  return Monitor;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.Monitor = Monitor;\n\nfunction resetMonitorState(monitor) {\n  var _a, _b, _c;\n\n  (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();\n  monitor[kMonitorId] = undefined;\n  (_b = monitor[kRTTPinger]) === null || _b === void 0 ? void 0 : _b.close();\n  monitor[kRTTPinger] = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({\n    force: true\n  });\n  monitor[kConnection] = undefined;\n}\n\nfunction checkServer(monitor, callback) {\n  var start = (0, utils_1.now)();\n  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    var _a;\n\n    (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    monitor[kConnection] = undefined;\n    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  var connection = monitor[kConnection];\n\n  if (connection && !connection.closed) {\n    var serverApi = connection.serverApi,\n        helloOk = connection.helloOk;\n    var connectTimeoutMS = monitor.options.connectTimeoutMS;\n    var maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    var topologyVersion = monitor[kServer].description.topologyVersion;\n    var isAwaitable = topologyVersion != null;\n\n    var cmd = _objectSpread(_defineProperty({}, (serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, true), isAwaitable && topologyVersion ? {\n      maxAwaitTimeMS: maxAwaitTimeMS,\n      topologyVersion: makeTopologyVersion(topologyVersion)\n    } : {});\n\n    var options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({\n        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS\n      }, monitor.connectOptions));\n    }\n\n    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, function (err, hello) {\n      var _a;\n\n      if (err) {\n        return failureHandler(err);\n      }\n\n      if (!('isWritablePrimary' in hello)) {\n        // Provide hello-style response document.\n        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n      }\n\n      var rttPinger = monitor[kRTTPinger];\n      var duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && hello.topologyVersion) {\n        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n        start = (0, utils_1.now)();\n      } else {\n        (_a = monitor[kRTTPinger]) === null || _a === void 0 ? void 0 : _a.close();\n        monitor[kRTTPinger] = undefined;\n        callback(undefined, hello);\n      }\n    });\n    return;\n  } // connecting does an implicit `hello`\n\n\n  (0, connect_1.connect)(monitor.connectOptions, function (err, conn) {\n    if (err) {\n      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases\n\n      if (!(err instanceof error_1.MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    if (conn) {\n      // Tell the connection that we are using the streaming protocol so that the\n      // connection's message stream will only read the last hello on the buffer.\n      conn.isMonitoringConnection = true;\n\n      if (isInCloseState(monitor)) {\n        conn.destroy({\n          force: true\n        });\n        return;\n      }\n\n      monitor[kConnection] = conn;\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));\n      callback(undefined, conn.hello);\n    }\n  });\n}\n\nfunction monitorServer(monitor) {\n  return function (callback) {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, function (err, hello) {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (hello && hello.topologyVersion) {\n        (0, timers_1.setTimeout)(function () {\n          var _a;\n\n          if (!isInCloseState(monitor)) {\n            (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\n\n\nvar RTTPinger = /*#__PURE__*/function () {\n  function RTTPinger(cancellationToken, options) {\n    var _this2 = this;\n\n    _classCallCheck(this, RTTPinger);\n\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    var heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = (0, timers_1.setTimeout)(function () {\n      return measureRoundTripTime(_this2, options);\n    }, heartbeatFrequencyMS);\n  }\n\n  _createClass(RTTPinger, [{\n    key: \"roundTripTime\",\n    get: function get() {\n      return this[kRoundTripTime];\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _a;\n\n      this.closed = true;\n      clearTimeout(this[kMonitorId]);\n      (_a = this[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n        force: true\n      });\n      this[kConnection] = undefined;\n    }\n  }]);\n\n  return RTTPinger;\n}();\n\nexports.RTTPinger = RTTPinger;\n\nfunction measureRoundTripTime(rttPinger, options) {\n  var start = (0, utils_1.now)();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  var heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn === null || conn === void 0 ? void 0 : conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);\n    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(function () {\n      return measureRoundTripTime(rttPinger, options);\n    }, heartbeatFrequencyMS);\n  }\n\n  var connection = rttPinger[kConnection];\n\n  if (connection == null) {\n    (0, connect_1.connect)(options, function (err, conn) {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  connection.command((0, utils_1.ns)('admin.$cmd'), _defineProperty({}, constants_1.LEGACY_HELLO_COMMAND, 1), undefined, function (err) {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}","map":null,"metadata":{},"sourceType":"script"}