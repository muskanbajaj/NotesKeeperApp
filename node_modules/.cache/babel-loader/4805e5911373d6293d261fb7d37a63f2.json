{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _get = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\n\nvar error_1 = require(\"../error\");\n\nvar write_concern_1 = require(\"../write_concern\");\n\nvar bulk_write_1 = require(\"./bulk_write\");\n\nvar command_1 = require(\"./command\");\n\nvar common_functions_1 = require(\"./common_functions\");\n\nvar operation_1 = require(\"./operation\");\n/** @internal */\n\n\nvar InsertOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(InsertOperation, _command_1$CommandOpe);\n\n  var _super = _createSuper(InsertOperation);\n\n  function InsertOperation(ns, documents, options) {\n    var _this;\n\n    _classCallCheck(this, InsertOperation);\n\n    var _a;\n\n    _this = _super.call(this, undefined, options);\n    _this.options = _objectSpread(_objectSpread({}, options), {}, {\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    });\n    _this.ns = ns;\n    _this.documents = documents;\n    return _this;\n  }\n\n  _createClass(InsertOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _a;\n\n      var options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n      var command = {\n        insert: this.ns.collection,\n        documents: this.documents,\n        ordered: ordered\n      };\n\n      if (typeof options.bypassDocumentValidation === 'boolean') {\n        command.bypassDocumentValidation = options.bypassDocumentValidation;\n      } // we check for undefined specifically here to allow falsy values\n      // eslint-disable-next-line no-restricted-syntax\n\n\n      if (options.comment !== undefined) {\n        command.comment = options.comment;\n      }\n\n      _get(_getPrototypeOf(InsertOperation.prototype), \"executeCommand\", this).call(this, server, session, command, callback);\n    }\n  }]);\n\n  return InsertOperation;\n}(command_1.CommandOperation);\n\nexports.InsertOperation = InsertOperation;\n\nvar InsertOneOperation = /*#__PURE__*/function (_InsertOperation) {\n  _inherits(InsertOneOperation, _InsertOperation);\n\n  var _super2 = _createSuper(InsertOneOperation);\n\n  function InsertOneOperation(collection, doc, options) {\n    _classCallCheck(this, InsertOneOperation);\n\n    return _super2.call(this, collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n\n  _createClass(InsertOneOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(InsertOneOperation.prototype), \"execute\", this).call(this, server, session, function (err, res) {\n        var _a, _b;\n\n        if (err || res == null) return callback(err);\n        if (res.code) return callback(new error_1.MongoServerError(res));\n\n        if (res.writeErrors) {\n          // This should be a WriteError but we can't change it now because of error hierarchy\n          return callback(new error_1.MongoServerError(res.writeErrors[0]));\n        }\n\n        callback(undefined, {\n          acknowledged: (_b = ((_a = _this2.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n          insertedId: _this2.documents[0]._id\n        });\n      });\n    }\n  }]);\n\n  return InsertOneOperation;\n}(InsertOperation);\n\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\n\nvar InsertManyOperation = /*#__PURE__*/function (_operation_1$Abstract) {\n  _inherits(InsertManyOperation, _operation_1$Abstract);\n\n  var _super3 = _createSuper(InsertManyOperation);\n\n  function InsertManyOperation(collection, docs, options) {\n    var _this3;\n\n    _classCallCheck(this, InsertManyOperation);\n\n    _this3 = _super3.call(this, options);\n\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    _this3.options = options;\n    _this3.collection = collection;\n    _this3.docs = docs;\n    return _this3;\n  }\n\n  _createClass(InsertManyOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var coll = this.collection;\n\n      var options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {\n        readPreference: this.readPreference\n      });\n\n      var writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n      var bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(function (document) {\n        return {\n          insertOne: {\n            document: document\n          }\n        };\n      }), options);\n      bulkWriteOperation.execute(server, session, function (err, res) {\n        var _a;\n\n        if (err || res == null) {\n          if (err && err.message === 'Operation must be an object with an operation key') {\n            err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n          }\n\n          return callback(err);\n        }\n\n        callback(undefined, {\n          acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n          insertedCount: res.insertedCount,\n          insertedIds: res.insertedIds\n        });\n      });\n    }\n  }]);\n\n  return InsertManyOperation;\n}(operation_1.AbstractOperation);\n\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":null,"metadata":{},"sourceType":"script"}