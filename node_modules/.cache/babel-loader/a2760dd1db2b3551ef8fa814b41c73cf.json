{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _inherits = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SrvPoller = exports.SrvPollingEvent = void 0;\n\nvar dns = require(\"dns\");\n\nvar timers_1 = require(\"timers\");\n\nvar error_1 = require(\"../error\");\n\nvar logger_1 = require(\"../logger\");\n\nvar mongo_types_1 = require(\"../mongo_types\");\n\nvar utils_1 = require(\"../utils\");\n/**\n * Determines whether a provided address matches the provided parent domain in order\n * to avoid certain attack vectors.\n *\n * @param srvAddress - The address to check against a domain\n * @param parentDomain - The domain to check the provided address against\n * @returns Whether the provided address matches the parent domain\n */\n\n\nfunction matchesParentDomain(srvAddress, parentDomain) {\n  var regex = /^.*?\\./;\n  var srv = \".\".concat(srvAddress.replace(regex, ''));\n  var parent = \".\".concat(parentDomain.replace(regex, ''));\n  return srv.endsWith(parent);\n}\n/**\n * @internal\n * @category Event\n */\n\n\nvar SrvPollingEvent = /*#__PURE__*/function () {\n  function SrvPollingEvent(srvRecords) {\n    _classCallCheck(this, SrvPollingEvent);\n\n    this.srvRecords = srvRecords;\n  }\n\n  _createClass(SrvPollingEvent, [{\n    key: \"hostnames\",\n    value: function hostnames() {\n      return new Set(this.srvRecords.map(function (r) {\n        return utils_1.HostAddress.fromSrvRecord(r).toString();\n      }));\n    }\n  }]);\n\n  return SrvPollingEvent;\n}();\n\nexports.SrvPollingEvent = SrvPollingEvent;\n/** @internal */\n\nvar SrvPoller = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(SrvPoller, _mongo_types_1$TypedE);\n\n  var _super = _createSuper(SrvPoller);\n\n  function SrvPoller(options) {\n    var _this;\n\n    _classCallCheck(this, SrvPoller);\n\n    var _a, _b, _c;\n\n    _this = _super.call(this);\n\n    if (!options || !options.srvHost) {\n      throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');\n    }\n\n    _this.srvHost = options.srvHost;\n    _this.srvMaxHosts = (_a = options.srvMaxHosts) !== null && _a !== void 0 ? _a : 0;\n    _this.srvServiceName = (_b = options.srvServiceName) !== null && _b !== void 0 ? _b : 'mongodb';\n    _this.rescanSrvIntervalMS = 60000;\n    _this.heartbeatFrequencyMS = (_c = options.heartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 10000;\n    _this.logger = new logger_1.Logger('srvPoller', options);\n    _this.haMode = false;\n    _this.generation = 0;\n    _this._timeout = undefined;\n    return _this;\n  }\n\n  _createClass(SrvPoller, [{\n    key: \"srvAddress\",\n    get: function get() {\n      return \"_\".concat(this.srvServiceName, \"._tcp.\").concat(this.srvHost);\n    }\n  }, {\n    key: \"intervalMS\",\n    get: function get() {\n      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this._timeout) {\n        this.schedule();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n        this.generation += 1;\n        this._timeout = undefined;\n      }\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule() {\n      var _this2 = this;\n\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n\n      this._timeout = (0, timers_1.setTimeout)(function () {\n        return _this2._poll();\n      }, this.intervalMS);\n    }\n  }, {\n    key: \"success\",\n    value: function success(srvRecords) {\n      this.haMode = false;\n      this.schedule();\n      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));\n    }\n  }, {\n    key: \"failure\",\n    value: function failure(message, obj) {\n      this.logger.warn(message, obj);\n      this.haMode = true;\n      this.schedule();\n    }\n  }, {\n    key: \"parentDomainMismatch\",\n    value: function parentDomainMismatch(srvRecord) {\n      this.logger.warn(\"parent domain mismatch on SRV record (\".concat(srvRecord.name, \":\").concat(srvRecord.port, \")\"), srvRecord);\n    }\n  }, {\n    key: \"_poll\",\n    value: function _poll() {\n      var _this3 = this;\n\n      var generation = this.generation;\n      dns.resolveSrv(this.srvAddress, function (err, srvRecords) {\n        if (generation !== _this3.generation) {\n          return;\n        }\n\n        if (err) {\n          _this3.failure('DNS error', err);\n\n          return;\n        }\n\n        var finalAddresses = [];\n\n        var _iterator = _createForOfIteratorHelper(srvRecords),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var record = _step.value;\n\n            if (matchesParentDomain(record.name, _this3.srvHost)) {\n              finalAddresses.push(record);\n            } else {\n              _this3.parentDomainMismatch(record);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!finalAddresses.length) {\n          _this3.failure('No valid addresses found at host');\n\n          return;\n        }\n\n        _this3.success(finalAddresses);\n      });\n    }\n  }]);\n\n  return SrvPoller;\n}(mongo_types_1.TypedEventEmitter);\n\nexports.SrvPoller = SrvPoller;\n/** @event */\n\nSrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';","map":null,"metadata":{},"sourceType":"script"}