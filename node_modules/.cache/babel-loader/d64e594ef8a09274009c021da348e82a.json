{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\muska\\\\OneDrive\\\\Desktop\\\\NotesApp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinMsg = exports.Msg = exports.Response = exports.KillCursor = exports.GetMore = exports.Query = void 0;\n\nvar BSON = require(\"../bson\");\n\nvar error_1 = require(\"../error\");\n\nvar read_preference_1 = require(\"../read_preference\");\n\nvar utils_1 = require(\"../utils\");\n\nvar constants_1 = require(\"./wire_protocol/constants\"); // Incrementing request id\n\n\nvar _requestId = 0; // Query flags\n\nvar OPTS_TAILABLE_CURSOR = 2;\nvar OPTS_SECONDARY = 4;\nvar OPTS_OPLOG_REPLAY = 8;\nvar OPTS_NO_CURSOR_TIMEOUT = 16;\nvar OPTS_AWAIT_DATA = 32;\nvar OPTS_EXHAUST = 64;\nvar OPTS_PARTIAL = 128; // Response flags\n\nvar CURSOR_NOT_FOUND = 1;\nvar QUERY_FAILURE = 2;\nvar SHARD_CONFIG_STALE = 4;\nvar AWAIT_CAPABLE = 8;\n/**************************************************************\n * QUERY\n **************************************************************/\n\n/** @internal */\n\nvar Query = /*#__PURE__*/function () {\n  function Query(ns, query, options) {\n    _classCallCheck(this, Query);\n\n    // Basic options needed to be passed in\n    // TODO(NODE-3483): Replace with MongoCommandError\n    if (ns == null) throw new error_1.MongoRuntimeError('Namespace must be specified for query'); // TODO(NODE-3483): Replace with MongoCommandError\n\n    if (query == null) throw new error_1.MongoRuntimeError('A query document must be specified for query'); // Validate that we are not passing 0x00 in the collection name\n\n    if (ns.indexOf('\\x00') !== -1) {\n      // TODO(NODE-3483): Use MongoNamespace static method\n      throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');\n    } // Basic options\n\n\n    this.ns = ns;\n    this.query = query; // Additional options\n\n    this.numberToSkip = options.numberToSkip || 0;\n    this.numberToReturn = options.numberToReturn || 0;\n    this.returnFieldSelector = options.returnFieldSelector || undefined;\n    this.requestId = Query.getRequestId(); // special case for pre-3.2 find commands, delete ASAP\n\n    this.pre32Limit = options.pre32Limit; // Serialization option\n\n    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.batchSize = this.numberToReturn; // Flags\n\n    this.tailable = false;\n    this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;\n    this.oplogReplay = false;\n    this.noCursorTimeout = false;\n    this.awaitData = false;\n    this.exhaust = false;\n    this.partial = false;\n  }\n  /** Assign next request Id. */\n\n\n  _createClass(Query, [{\n    key: \"incRequestId\",\n    value: function incRequestId() {\n      this.requestId = _requestId++;\n    }\n    /** Peek next request Id. */\n\n  }, {\n    key: \"nextRequestId\",\n    value: function nextRequestId() {\n      return _requestId + 1;\n    }\n    /** Increment then return next request Id. */\n\n  }, {\n    key: \"toBin\",\n    value: // Uses a single allocated buffer for the process, avoiding multiple memory allocations\n    function toBin() {\n      var buffers = [];\n      var projection = null; // Set up the flags\n\n      var flags = 0;\n\n      if (this.tailable) {\n        flags |= OPTS_TAILABLE_CURSOR;\n      }\n\n      if (this.secondaryOk) {\n        flags |= OPTS_SECONDARY;\n      }\n\n      if (this.oplogReplay) {\n        flags |= OPTS_OPLOG_REPLAY;\n      }\n\n      if (this.noCursorTimeout) {\n        flags |= OPTS_NO_CURSOR_TIMEOUT;\n      }\n\n      if (this.awaitData) {\n        flags |= OPTS_AWAIT_DATA;\n      }\n\n      if (this.exhaust) {\n        flags |= OPTS_EXHAUST;\n      }\n\n      if (this.partial) {\n        flags |= OPTS_PARTIAL;\n      } // If batchSize is different to this.numberToReturn\n\n\n      if (this.batchSize !== this.numberToReturn) this.numberToReturn = this.batchSize; // Allocate write protocol header buffer\n\n      var header = Buffer.alloc(4 * 4 + // Header\n      4 + // Flags\n      Buffer.byteLength(this.ns) + 1 + // namespace\n      4 + // numberToSkip\n      4 // numberToReturn\n      ); // Add header to buffers\n\n      buffers.push(header); // Serialize the query\n\n      var query = BSON.serialize(this.query, {\n        checkKeys: this.checkKeys,\n        serializeFunctions: this.serializeFunctions,\n        ignoreUndefined: this.ignoreUndefined\n      }); // Add query document\n\n      buffers.push(query);\n\n      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {\n        // Serialize the projection document\n        projection = BSON.serialize(this.returnFieldSelector, {\n          checkKeys: this.checkKeys,\n          serializeFunctions: this.serializeFunctions,\n          ignoreUndefined: this.ignoreUndefined\n        }); // Add projection document\n\n        buffers.push(projection);\n      } // Total message size\n\n\n      var totalLength = header.length + query.length + (projection ? projection.length : 0); // Set up the index\n\n      var index = 4; // Write total document length\n\n      header[3] = totalLength >> 24 & 0xff;\n      header[2] = totalLength >> 16 & 0xff;\n      header[1] = totalLength >> 8 & 0xff;\n      header[0] = totalLength & 0xff; // Write header information requestId\n\n      header[index + 3] = this.requestId >> 24 & 0xff;\n      header[index + 2] = this.requestId >> 16 & 0xff;\n      header[index + 1] = this.requestId >> 8 & 0xff;\n      header[index] = this.requestId & 0xff;\n      index = index + 4; // Write header information responseTo\n\n      header[index + 3] = 0 >> 24 & 0xff;\n      header[index + 2] = 0 >> 16 & 0xff;\n      header[index + 1] = 0 >> 8 & 0xff;\n      header[index] = 0 & 0xff;\n      index = index + 4; // Write header information OP_QUERY\n\n      header[index + 3] = constants_1.OP_QUERY >> 24 & 0xff;\n      header[index + 2] = constants_1.OP_QUERY >> 16 & 0xff;\n      header[index + 1] = constants_1.OP_QUERY >> 8 & 0xff;\n      header[index] = constants_1.OP_QUERY & 0xff;\n      index = index + 4; // Write header information flags\n\n      header[index + 3] = flags >> 24 & 0xff;\n      header[index + 2] = flags >> 16 & 0xff;\n      header[index + 1] = flags >> 8 & 0xff;\n      header[index] = flags & 0xff;\n      index = index + 4; // Write collection name\n\n      index = index + header.write(this.ns, index, 'utf8') + 1;\n      header[index - 1] = 0; // Write header information flags numberToSkip\n\n      header[index + 3] = this.numberToSkip >> 24 & 0xff;\n      header[index + 2] = this.numberToSkip >> 16 & 0xff;\n      header[index + 1] = this.numberToSkip >> 8 & 0xff;\n      header[index] = this.numberToSkip & 0xff;\n      index = index + 4; // Write header information flags numberToReturn\n\n      header[index + 3] = this.numberToReturn >> 24 & 0xff;\n      header[index + 2] = this.numberToReturn >> 16 & 0xff;\n      header[index + 1] = this.numberToReturn >> 8 & 0xff;\n      header[index] = this.numberToReturn & 0xff;\n      index = index + 4; // Return the buffers\n\n      return buffers;\n    }\n  }], [{\n    key: \"getRequestId\",\n    value: function getRequestId() {\n      return ++_requestId;\n    }\n  }]);\n\n  return Query;\n}();\n\nexports.Query = Query;\n/**************************************************************\n * GETMORE\n **************************************************************/\n\n/** @internal */\n\nvar GetMore = /*#__PURE__*/function () {\n  function GetMore(ns, cursorId) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, GetMore);\n\n    this.numberToReturn = opts.numberToReturn || 0;\n    this.requestId = _requestId++;\n    this.ns = ns;\n    this.cursorId = cursorId;\n  } // Uses a single allocated buffer for the process, avoiding multiple memory allocations\n\n\n  _createClass(GetMore, [{\n    key: \"toBin\",\n    value: function toBin() {\n      var length = 4 + Buffer.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4; // Create command buffer\n\n      var index = 0; // Allocate buffer\n\n      var _buffer = Buffer.alloc(length); // Write header information\n      // index = write32bit(index, _buffer, length);\n\n\n      _buffer[index + 3] = length >> 24 & 0xff;\n      _buffer[index + 2] = length >> 16 & 0xff;\n      _buffer[index + 1] = length >> 8 & 0xff;\n      _buffer[index] = length & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, requestId);\n\n      _buffer[index + 3] = this.requestId >> 24 & 0xff;\n      _buffer[index + 2] = this.requestId >> 16 & 0xff;\n      _buffer[index + 1] = this.requestId >> 8 & 0xff;\n      _buffer[index] = this.requestId & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, 0);\n\n      _buffer[index + 3] = 0 >> 24 & 0xff;\n      _buffer[index + 2] = 0 >> 16 & 0xff;\n      _buffer[index + 1] = 0 >> 8 & 0xff;\n      _buffer[index] = 0 & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, OP_GETMORE);\n\n      _buffer[index + 3] = constants_1.OP_GETMORE >> 24 & 0xff;\n      _buffer[index + 2] = constants_1.OP_GETMORE >> 16 & 0xff;\n      _buffer[index + 1] = constants_1.OP_GETMORE >> 8 & 0xff;\n      _buffer[index] = constants_1.OP_GETMORE & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, 0);\n\n      _buffer[index + 3] = 0 >> 24 & 0xff;\n      _buffer[index + 2] = 0 >> 16 & 0xff;\n      _buffer[index + 1] = 0 >> 8 & 0xff;\n      _buffer[index] = 0 & 0xff;\n      index = index + 4; // Write collection name\n\n      index = index + _buffer.write(this.ns, index, 'utf8') + 1;\n      _buffer[index - 1] = 0; // Write batch size\n      // index = write32bit(index, _buffer, numberToReturn);\n\n      _buffer[index + 3] = this.numberToReturn >> 24 & 0xff;\n      _buffer[index + 2] = this.numberToReturn >> 16 & 0xff;\n      _buffer[index + 1] = this.numberToReturn >> 8 & 0xff;\n      _buffer[index] = this.numberToReturn & 0xff;\n      index = index + 4; // Write cursor id\n      // index = write32bit(index, _buffer, cursorId.getLowBits());\n\n      _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 0xff;\n      _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 0xff;\n      _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 0xff;\n      _buffer[index] = this.cursorId.getLowBits() & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, cursorId.getHighBits());\n\n      _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 0xff;\n      _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 0xff;\n      _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 0xff;\n      _buffer[index] = this.cursorId.getHighBits() & 0xff;\n      index = index + 4; // Return buffer\n\n      return [_buffer];\n    }\n  }]);\n\n  return GetMore;\n}();\n\nexports.GetMore = GetMore;\n/**************************************************************\n * KILLCURSOR\n **************************************************************/\n\n/** @internal */\n\nvar KillCursor = /*#__PURE__*/function () {\n  function KillCursor(ns, cursorIds) {\n    _classCallCheck(this, KillCursor);\n\n    this.ns = ns;\n    this.requestId = _requestId++;\n    this.cursorIds = cursorIds;\n  } // Uses a single allocated buffer for the process, avoiding multiple memory allocations\n\n\n  _createClass(KillCursor, [{\n    key: \"toBin\",\n    value: function toBin() {\n      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8; // Create command buffer\n\n      var index = 0;\n\n      var _buffer = Buffer.alloc(length); // Write header information\n      // index = write32bit(index, _buffer, length);\n\n\n      _buffer[index + 3] = length >> 24 & 0xff;\n      _buffer[index + 2] = length >> 16 & 0xff;\n      _buffer[index + 1] = length >> 8 & 0xff;\n      _buffer[index] = length & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, requestId);\n\n      _buffer[index + 3] = this.requestId >> 24 & 0xff;\n      _buffer[index + 2] = this.requestId >> 16 & 0xff;\n      _buffer[index + 1] = this.requestId >> 8 & 0xff;\n      _buffer[index] = this.requestId & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, 0);\n\n      _buffer[index + 3] = 0 >> 24 & 0xff;\n      _buffer[index + 2] = 0 >> 16 & 0xff;\n      _buffer[index + 1] = 0 >> 8 & 0xff;\n      _buffer[index] = 0 & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, OP_KILL_CURSORS);\n\n      _buffer[index + 3] = constants_1.OP_KILL_CURSORS >> 24 & 0xff;\n      _buffer[index + 2] = constants_1.OP_KILL_CURSORS >> 16 & 0xff;\n      _buffer[index + 1] = constants_1.OP_KILL_CURSORS >> 8 & 0xff;\n      _buffer[index] = constants_1.OP_KILL_CURSORS & 0xff;\n      index = index + 4; // index = write32bit(index, _buffer, 0);\n\n      _buffer[index + 3] = 0 >> 24 & 0xff;\n      _buffer[index + 2] = 0 >> 16 & 0xff;\n      _buffer[index + 1] = 0 >> 8 & 0xff;\n      _buffer[index] = 0 & 0xff;\n      index = index + 4; // Write batch size\n      // index = write32bit(index, _buffer, this.cursorIds.length);\n\n      _buffer[index + 3] = this.cursorIds.length >> 24 & 0xff;\n      _buffer[index + 2] = this.cursorIds.length >> 16 & 0xff;\n      _buffer[index + 1] = this.cursorIds.length >> 8 & 0xff;\n      _buffer[index] = this.cursorIds.length & 0xff;\n      index = index + 4; // Write all the cursor ids into the array\n\n      for (var i = 0; i < this.cursorIds.length; i++) {\n        // Write cursor id\n        // index = write32bit(index, _buffer, cursorIds[i].getLowBits());\n        _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 0xff;\n        _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 0xff;\n        _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 0xff;\n        _buffer[index] = this.cursorIds[i].getLowBits() & 0xff;\n        index = index + 4; // index = write32bit(index, _buffer, cursorIds[i].getHighBits());\n\n        _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 0xff;\n        _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 0xff;\n        _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 0xff;\n        _buffer[index] = this.cursorIds[i].getHighBits() & 0xff;\n        index = index + 4;\n      } // Return buffer\n\n\n      return [_buffer];\n    }\n  }]);\n\n  return KillCursor;\n}();\n\nexports.KillCursor = KillCursor;\n/** @internal */\n\nvar Response = /*#__PURE__*/function () {\n  function Response(message, msgHeader, msgBody, opts) {\n    _classCallCheck(this, Response);\n\n    this.documents = new Array(0);\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.opts = opts !== null && opts !== void 0 ? opts : {\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false\n    }; // Read the message header\n\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed; // Flag values\n\n    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;\n    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;\n    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;\n    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;\n  }\n\n  _createClass(Response, [{\n    key: \"isParsed\",\n    value: function isParsed() {\n      return this.parsed;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(options) {\n      var _a, _b, _c, _d; // Don't parse again if not needed\n\n\n      if (this.parsed) return;\n      options = options !== null && options !== void 0 ? options : {}; // Allow the return of raw documents instead of parsing\n\n      var raw = options.raw || false;\n      var documentsReturnedIn = options.documentsReturnedIn || null;\n      var promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;\n      var promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;\n      var promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;\n      var bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;\n      var bsonSize; // Set up the options\n\n      var _options = {\n        promoteLongs: promoteLongs,\n        promoteValues: promoteValues,\n        promoteBuffers: promoteBuffers,\n        bsonRegExp: bsonRegExp\n      }; // Position within OP_REPLY at which documents start\n      // (See https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#wire-op-reply)\n\n      this.index = 20; // Read the message body\n\n      this.responseFlags = this.data.readInt32LE(0);\n      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));\n      this.startingFrom = this.data.readInt32LE(12);\n      this.numberReturned = this.data.readInt32LE(16); // Preallocate document array\n\n      this.documents = new Array(this.numberReturned);\n      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;\n      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;\n      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;\n      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0; // Parse Body\n\n      for (var i = 0; i < this.numberReturned; i++) {\n        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24; // If we have raw results specified slice the return document\n\n        if (raw) {\n          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);\n        } else {\n          this.documents[i] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);\n        } // Adjust the index\n\n\n        this.index = this.index + bsonSize;\n      }\n\n      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {\n        var fieldsAsRaw = {};\n        fieldsAsRaw[documentsReturnedIn] = true;\n        _options.fieldsAsRaw = fieldsAsRaw;\n        var doc = BSON.deserialize(this.documents[0], _options);\n        this.documents = [doc];\n      } // Set parsed\n\n\n      this.parsed = true;\n    }\n  }]);\n\n  return Response;\n}();\n\nexports.Response = Response; // Implementation of OP_MSG spec:\n// https://github.com/mongodb/specifications/blob/master/source/message/OP_MSG.rst\n//\n// struct Section {\n//   uint8 payloadType;\n//   union payload {\n//       document  document; // payloadType == 0\n//       struct sequence { // payloadType == 1\n//           int32      size;\n//           cstring    identifier;\n//           document*  documents;\n//       };\n//   };\n// };\n// struct OP_MSG {\n//   struct MsgHeader {\n//       int32  messageLength;\n//       int32  requestID;\n//       int32  responseTo;\n//       int32  opCode = 2013;\n//   };\n//   uint32      flagBits;\n//   Section+    sections;\n//   [uint32     checksum;]\n// };\n// Msg Flags\n\nvar OPTS_CHECKSUM_PRESENT = 1;\nvar OPTS_MORE_TO_COME = 2;\nvar OPTS_EXHAUST_ALLOWED = 1 << 16;\n/** @internal */\n\nvar Msg = /*#__PURE__*/function () {\n  function Msg(ns, command, options) {\n    _classCallCheck(this, Msg);\n\n    // Basic options needed to be passed in\n    if (command == null) throw new error_1.MongoInvalidArgumentError('Query document must be specified for query'); // Basic options\n\n    this.ns = ns;\n    this.command = command;\n    this.command.$db = (0, utils_1.databaseNamespace)(ns);\n\n    if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {\n      this.command.$readPreference = options.readPreference.toJSON();\n    } // Ensure empty options\n\n\n    this.options = options !== null && options !== void 0 ? options : {}; // Additional options\n\n    this.requestId = options.requestId ? options.requestId : Msg.getRequestId(); // Serialization option\n\n    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16; // flags\n\n    this.checksumPresent = false;\n    this.moreToCome = options.moreToCome || false;\n    this.exhaustAllowed = typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;\n  }\n\n  _createClass(Msg, [{\n    key: \"toBin\",\n    value: function toBin() {\n      var buffers = [];\n      var flags = 0;\n\n      if (this.checksumPresent) {\n        flags |= OPTS_CHECKSUM_PRESENT;\n      }\n\n      if (this.moreToCome) {\n        flags |= OPTS_MORE_TO_COME;\n      }\n\n      if (this.exhaustAllowed) {\n        flags |= OPTS_EXHAUST_ALLOWED;\n      }\n\n      var header = Buffer.alloc(4 * 4 + // Header\n      4 // Flags\n      );\n      buffers.push(header);\n      var totalLength = header.length;\n      var command = this.command;\n      totalLength += this.makeDocumentSegment(buffers, command);\n      header.writeInt32LE(totalLength, 0); // messageLength\n\n      header.writeInt32LE(this.requestId, 4); // requestID\n\n      header.writeInt32LE(0, 8); // responseTo\n\n      header.writeInt32LE(constants_1.OP_MSG, 12); // opCode\n\n      header.writeUInt32LE(flags, 16); // flags\n\n      return buffers;\n    }\n  }, {\n    key: \"makeDocumentSegment\",\n    value: function makeDocumentSegment(buffers, document) {\n      var payloadTypeBuffer = Buffer.alloc(1);\n      payloadTypeBuffer[0] = 0;\n      var documentBuffer = this.serializeBson(document);\n      buffers.push(payloadTypeBuffer);\n      buffers.push(documentBuffer);\n      return payloadTypeBuffer.length + documentBuffer.length;\n    }\n  }, {\n    key: \"serializeBson\",\n    value: function serializeBson(document) {\n      return BSON.serialize(document, {\n        checkKeys: this.checkKeys,\n        serializeFunctions: this.serializeFunctions,\n        ignoreUndefined: this.ignoreUndefined\n      });\n    }\n  }], [{\n    key: \"getRequestId\",\n    value: function getRequestId() {\n      _requestId = _requestId + 1 & 0x7fffffff;\n      return _requestId;\n    }\n  }]);\n\n  return Msg;\n}();\n\nexports.Msg = Msg;\n/** @internal */\n\nvar BinMsg = /*#__PURE__*/function () {\n  function BinMsg(message, msgHeader, msgBody, opts) {\n    _classCallCheck(this, BinMsg);\n\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.opts = opts !== null && opts !== void 0 ? opts : {\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false\n    }; // Read the message header\n\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed; // Read response flags\n\n    this.responseFlags = msgBody.readInt32LE(0);\n    this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;\n    this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;\n    this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;\n    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;\n    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;\n    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;\n    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;\n    this.documents = [];\n  }\n\n  _createClass(BinMsg, [{\n    key: \"isParsed\",\n    value: function isParsed() {\n      return this.parsed;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(options) {\n      var _a, _b, _c, _d; // Don't parse again if not needed\n\n\n      if (this.parsed) return;\n      options = options !== null && options !== void 0 ? options : {};\n      this.index = 4; // Allow the return of raw documents instead of parsing\n\n      var raw = options.raw || false;\n      var documentsReturnedIn = options.documentsReturnedIn || null;\n      var promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;\n      var promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;\n      var promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;\n      var bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;\n      var validation = this.parseBsonSerializationOptions(options); // Set up the options\n\n      var bsonOptions = {\n        promoteLongs: promoteLongs,\n        promoteValues: promoteValues,\n        promoteBuffers: promoteBuffers,\n        bsonRegExp: bsonRegExp,\n        validation: validation // Due to the strictness of the BSON libraries validation option we need this cast\n\n      };\n\n      while (this.index < this.data.length) {\n        var payloadType = this.data.readUInt8(this.index++);\n\n        if (payloadType === 0) {\n          var bsonSize = this.data.readUInt32LE(this.index);\n          var bin = this.data.slice(this.index, this.index + bsonSize);\n          this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));\n          this.index += bsonSize;\n        } else if (payloadType === 1) {\n          // It was decided that no driver makes use of payload type 1\n          // TODO(NODE-3483): Replace with MongoDeprecationError\n          throw new error_1.MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');\n        }\n      }\n\n      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {\n        var fieldsAsRaw = {};\n        fieldsAsRaw[documentsReturnedIn] = true;\n        bsonOptions.fieldsAsRaw = fieldsAsRaw;\n        var doc = BSON.deserialize(this.documents[0], bsonOptions);\n        this.documents = [doc];\n      }\n\n      this.parsed = true;\n    }\n  }, {\n    key: \"parseBsonSerializationOptions\",\n    value: function parseBsonSerializationOptions(_ref) {\n      var enableUtf8Validation = _ref.enableUtf8Validation;\n\n      if (enableUtf8Validation === false) {\n        return {\n          utf8: false\n        };\n      }\n\n      return {\n        utf8: {\n          writeErrors: false\n        }\n      };\n    }\n  }]);\n\n  return BinMsg;\n}();\n\nexports.BinMsg = BinMsg;","map":null,"metadata":{},"sourceType":"script"}